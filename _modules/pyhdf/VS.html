
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>pyhdf.VS &#8212; pyhdf 0.10.2 documentation</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pyhdf 0.10.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pyhdf.VS</h1><div class="highlight"><pre>
<span></span><span class="c1"># $Id: VS.py,v 1.4 2005-07-14 01:36:41 gosselin_a Exp $</span>
<span class="c1"># $Log: not supported by cvs2svn $</span>
<span class="c1"># Revision 1.3  2004/08/02 17:06:20  gosselin</span>
<span class="c1"># pyhdf-0.7.2</span>
<span class="c1">#</span>
<span class="c1"># Revision 1.2  2004/08/02 15:36:04  gosselin</span>
<span class="c1"># pyhdf-0.7-1</span>
<span class="c1">#</span>
<span class="c1"># Author: Andre Gosselin</span>
<span class="c1">#         Maurice-Lamontagne Institute</span>
<span class="c1">#         gosselina@dfo-mpo.gc.ca</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">VS (Vdata table) API (:mod:`pyhdf.VS`)</span>
<span class="sd">======================================</span>

<span class="sd">A module of the pyhdf package implementing the VS (Vdata table)</span>
<span class="sd">API of the NCSA HDF4 library.</span>

<span class="sd">Introduction</span>
<span class="sd">------------</span>
<span class="sd">VS is one of the modules composing pyhdf, a python package implementing</span>
<span class="sd">the NCSA HDF library and letting one manage HDF files from within a python</span>
<span class="sd">program. Two versions of the HDF library currently exist, version 4 and</span>
<span class="sd">version 5. pyhdf only implements version 4 of the library. Many</span>
<span class="sd">different APIs are to be found inside the HDF4 specification.</span>
<span class="sd">Currently, pyhdf implements just a few of those: the SD, VS and V APIs.</span>
<span class="sd">Other APIs should be added in the future (GR, AN, etc).</span>

<span class="sd">VS allows the definition of structured data tables inside an HDF file.</span>
<span class="sd">Those tables are designated as &quot;vdatas&quot; (the name has to do with data</span>
<span class="sd">associated with the &quot;vertices&quot; of geometrical models, the storage of which</span>
<span class="sd">the API was originally designed for). A vdata is composed of a fixed</span>
<span class="sd">number of columns (also called fields), where a column can store a fixed</span>
<span class="sd">number of data values, all of the same type. The number of values allowed</span>
<span class="sd">inside a field is called the &quot;order&quot; of the field. A table is composed of a</span>
<span class="sd">varying number of rows (also called records), a record representing the</span>
<span class="sd">sequence of values stored in each field of the vdata.</span>

<span class="sd">A vdata is associated with a descriptive name, and likewise each field of</span>
<span class="sd">the vdata. A vdata can also be tagged with a &quot;class&quot; to further describe the</span>
<span class="sd">vdata purpose. Records and fields are identified by a zero-based index.</span>
<span class="sd">An arbitrary number of attributes of different types can be attached to</span>
<span class="sd">a vdata as a whole, or to its individual fields. An attribute is a</span>
<span class="sd">(name, value) pair, where &quot;value&quot; can be of many types, and be either</span>
<span class="sd">single or multi-valued. The number of values stored in an attribute is</span>
<span class="sd">called the &quot;order&quot; of the attribute.</span>

<span class="sd">The following example illustrates a simple vdata that could be stored</span>
<span class="sd">inside an HDF file. See section &quot;Programming models&quot; for an example</span>
<span class="sd">program implementing this vdata.</span>

<span class="sd">                             INVENTORY (experimental status)</span>

<span class="sd">            ======     ===========     ===   ========  ========</span>
<span class="sd">            partid     description     qty   wght(lb)  price($)</span>
<span class="sd">            ======     ===========     ===   ========  ========</span>
<span class="sd">            Q1234       bolt           12     0.01      0.05</span>
<span class="sd">            B5432       brush          10     0.4       4.25</span>
<span class="sd">            S7613       scissor         2     0.2       3.75</span>
<span class="sd">            ======     ===========     ===   ========  ========</span>

<span class="sd">The vdata is composed of 5 fields. 3 records are shown (of course, a vdata</span>
<span class="sd">can store much more than that). &quot;INVENTORY&quot; would be the vdata name, and</span>
<span class="sd">&quot;partid&quot;, &quot;description&quot;, etc, would be the field names. The data type varies</span>
<span class="sd">between fields. &quot;partid&quot; and &quot;description&quot; would be of &quot;multicharacter&quot; type</span>
<span class="sd">(aka &quot;string&quot;), &quot;qty&quot; would be a integer, and &quot;wght&quot; and &quot;price&quot; would be</span>
<span class="sd">floats. The text in parentheses could be stored as attributes. A &quot;status&quot;</span>
<span class="sd">attribute could be defined for the table as a whole, and given the</span>
<span class="sd">value &quot;experimental&quot;. Likewise, a &quot;unit&quot; attribute could be associated</span>
<span class="sd">with fields &quot;wght&quot; and &quot;price&quot;, and given the values &quot;lb&quot; and &quot;$&quot;, resp.</span>

<span class="sd">The VS API allows one to create, locate and open a vdata inside an</span>
<span class="sd">HDF file, update and append records inside it, read records randomly</span>
<span class="sd">or sequentially, and access and update the vdata and field attributes.</span>
<span class="sd">Attributes can be read and written using the familiar python &quot;dot</span>
<span class="sd">notation&quot;, and records can be read and written by indexing and slicing the</span>
<span class="sd">vdata as if it were a python sequence.</span>

<span class="sd">VS module key features</span>
<span class="sd">----------------------</span>
<span class="sd">VS key features are as follows.</span>

<span class="sd">- pyhdf implements almost every routine of the original VS API.</span>
<span class="sd">  Only a few have been ignored, most of them being of a rare use:</span>

<span class="sd">  - VSgetblocksize() / VSsetblocksize()</span>
<span class="sd">  - VSsetnumblocks()</span>
<span class="sd">  - VSlone</span>

<span class="sd">- It is quite straightforward to go from a C version to a python version</span>
<span class="sd">  of a program accessing the VS API, and to learn VS usage by referring to</span>
<span class="sd">  the C API documentation.</span>

<span class="sd">- A few high-level python methods have been developed to ease</span>
<span class="sd">  programmers task. Of greatest interest are the following:</span>

<span class="sd">  - Access to attributes through the familiar &quot;dot notation&quot;.</span>
<span class="sd">  - Indexing and slicing a vdata to read and write its records,</span>
<span class="sd">    similarly to a python sequence.</span>
<span class="sd">  - Easy retrieval of info on a vdata and its fields.</span>
<span class="sd">  - Easy creation of vdatas.</span>

<span class="sd">Accessing the VS module</span>
<span class="sd">-----------------------</span>
<span class="sd">To access the VS module a python program can say one of:</span>

<span class="sd">  &gt;&gt;&gt; import pyhdf.VS        # must prefix names with &quot;pyhdf.VS.&quot;</span>
<span class="sd">  &gt;&gt;&gt; from pyhdf import VS   # must prefix names with &quot;VS.&quot;</span>
<span class="sd">  &gt;&gt;&gt; from pyhdf.VS import * # names need no prefix</span>

<span class="sd">This document assumes the last import style is used.</span>

<span class="sd">VS is not self-contained, and needs functionality provided by another</span>
<span class="sd">pyhdf module, namely the HDF module. This module must thus be imported</span>
<span class="sd">also:</span>

<span class="sd">  &gt;&gt;&gt; from .HDF import *</span>

<span class="sd">Package components</span>
<span class="sd">------------------</span>
<span class="sd">pyhdf is a proper Python package, eg a collection of modules stored under</span>
<span class="sd">a directory whose name is that of the package and which stores an</span>
<span class="sd">__init__.py file. Following the normal installation procedure, this</span>
<span class="sd">directory will be &lt;python-lib&gt;/site-packages/pyhdf&#39;, where &lt;python-lib&gt;</span>
<span class="sd">stands for the python installation directory.</span>

<span class="sd">For each HDF API exists a corresponding set of modules.</span>

<span class="sd">The following modules are related to the VS API.</span>

<span class="sd">  _hdfext</span>
<span class="sd">    C extension module responsible for wrapping the HDF</span>
<span class="sd">    C library for all python modules</span>
<span class="sd">  hdfext</span>
<span class="sd">    python module implementing some utility functions</span>
<span class="sd">    complementing the _hdfext extension module</span>
<span class="sd">  error</span>
<span class="sd">    defines the HDF4Error exception</span>
<span class="sd">  HDF</span>
<span class="sd">    python module providing support to the VS module</span>
<span class="sd">  VS</span>
<span class="sd">    python module wrapping the VS API routines inside</span>
<span class="sd">    an OOP framework</span>

<span class="sd">_hdfext and hdfext were generated using the SWIG preprocessor.</span>
<span class="sd">SWIG is however *not* needed to run the package. Those two modules</span>
<span class="sd">are meant to do their work in the background, and should never be called</span>
<span class="sd">directly. Only HDF and VS should be imported by the user program.</span>

<span class="sd">Prerequisites</span>
<span class="sd">-------------</span>
<span class="sd">The following software must be installed in order for VS to</span>
<span class="sd">work.</span>

<span class="sd">  HDF (v4) library</span>
<span class="sd">    pyhdf does *not* include the HDF4 library, which must</span>
<span class="sd">    be installed separately.</span>

<span class="sd">    HDF is available at:</span>
<span class="sd">    &quot;https://portal.hdfgroup.org/display/support/Download+HDF4&quot;.</span>

<span class="sd">Numeric is also needed by the SD module. See the SD module documentation.</span>

<span class="sd">Documentation</span>
<span class="sd">-------------</span>
<span class="sd">pyhdf has been written so as to stick as closely as possible to</span>
<span class="sd">the naming conventions and calling sequences documented inside the</span>
<span class="sd">&quot;HDF User s Guide&quot; manual. Even if pyhdf gives an OOP twist</span>
<span class="sd">to the C API, the manual can be easily used as a documentary source</span>
<span class="sd">for pyhdf, once the class to which a function belongs has been</span>
<span class="sd">identified, and of course once requirements imposed by the Python</span>
<span class="sd">language have been taken into account. Consequently, this documentation</span>
<span class="sd">will not attempt to provide an exhaustive coverage of the HDF VS</span>
<span class="sd">API. For this, the user is referred to the above manual.</span>
<span class="sd">The documentation of each pyhdf method will indicate the name</span>
<span class="sd">of the equivalent routine as it is found inside the C API.</span>

<span class="sd">This document (in both its text and html versions) has been completely</span>
<span class="sd">produced using &quot;pydoc&quot;, the Python documentation generator (which</span>
<span class="sd">made its debut in the 2.1 Python release). pydoc can also be used</span>
<span class="sd">as an on-line help tool. For example, to know everything about</span>
<span class="sd">the VS.VD class, say:</span>

<span class="sd">  &gt;&gt;&gt; from pydoc import help</span>
<span class="sd">  &gt;&gt;&gt; from pyhdf.VS import *</span>
<span class="sd">  &gt;&gt;&gt; help(VD)</span>

<span class="sd">To be more specific and get help only for the read() method of the</span>
<span class="sd">VD class:</span>

<span class="sd">  &gt;&gt;&gt; help(VD.read)</span>

<span class="sd">pydoc can also be called from the command line, as in::</span>

<span class="sd">  % pydoc pyhdf.VS.VD         # doc for the whole VD class</span>
<span class="sd">  % pydoc pyhdf.VS.VD.read    # doc for the VD.read method</span>

<span class="sd">Summary of differences between the pyhdf and C VS API</span>
<span class="sd">-----------------------------------------------------</span>
<span class="sd">Most of the differences between the pyhdf and C VS API can</span>
<span class="sd">be summarized as follows.</span>

<span class="sd">- In the C API, every function returns an integer status code, and values</span>
<span class="sd">  computed by the function are returned through one or more pointers</span>
<span class="sd">  passed as arguments.</span>
<span class="sd">- In pyhdf, error statuses are returned through the Python exception</span>
<span class="sd">  mechanism, and values are returned as the method result. When the</span>
<span class="sd">  C API specifies that multiple values are returned, pyhdf returns a</span>
<span class="sd">  sequence of values, which are ordered similarly to the pointers in the</span>
<span class="sd">  C function argument list.</span>

<span class="sd">Error handling</span>
<span class="sd">--------------</span>
<span class="sd">All errors reported by the C VS API with a SUCCESS/FAIL error code</span>
<span class="sd">are reported by pyhdf using the Python exception mechanism.</span>
<span class="sd">When the C library reports a FAIL status, pyhdf raises an HDF4Error</span>
<span class="sd">exception (a subclass of Exception) with a descriptive message.</span>
<span class="sd">Unfortunately, the C library is rarely informative about the cause of</span>
<span class="sd">the error. pyhdf does its best to try to document the error, but most</span>
<span class="sd">of the time cannot do more than saying &quot;execution error&quot;.</span>

<span class="sd">VS needs support from the HDF module</span>
<span class="sd">------------------------------------</span>
<span class="sd">The VS module is not self-contained (countrary to the SD module).</span>
<span class="sd">It requires help from the HDF module, namely:</span>

<span class="sd">- the HDF.HDF class to open and close the HDF file, and initialize the</span>
<span class="sd">  VS interface</span>
<span class="sd">- the HDF.HC class to provide different sorts of constants (opening modes,</span>
<span class="sd">  data types, etc).</span>

<span class="sd">A program wanting to access HDF vdatas will almost always need to execute</span>
<span class="sd">the following minimal set of calls:</span>

<span class="sd">  &gt;&gt;&gt; from pyhdf.HDF import *</span>
<span class="sd">  &gt;&gt;&gt; from pyhdf.VS import *</span>
<span class="sd">  &gt;&gt;&gt; hdfFile = HDF(name, HC.xxx)# open HDF file</span>
<span class="sd">  &gt;&gt;&gt; vs = hdfFile.vstart()      # initialize VS interface on HDF file</span>
<span class="sd">  &gt;&gt;&gt; ...                        # manipulate vdatas through &quot;vs&quot;</span>
<span class="sd">  &gt;&gt;&gt; vs.end()                   # terminate VS interface</span>
<span class="sd">  &gt;&gt;&gt; hdfFile.close()            # close HDF file</span>

<span class="sd">Classes summary</span>
<span class="sd">---------------</span>
<span class="sd">pyhdf wraps the VS API using different python classes::</span>

<span class="sd">  VS      HDF VS interface</span>
<span class="sd">  VD      vdata</span>
<span class="sd">  VDField vdata field</span>
<span class="sd">  VDattr  attribute (either at the vdata or field level)</span>

<span class="sd">In more detail::</span>

<span class="sd">  VS     The VS class implements the VS (Vdata) interface applied to an</span>
<span class="sd">         HDF file. This class encapsulates the hdf instance, and all</span>
<span class="sd">         the top-level functions of the VS API.</span>

<span class="sd">         To create a VS instance, call the vstart() method of an</span>
<span class="sd">         HDF instance.</span>

<span class="sd">         methods:</span>
<span class="sd">           constructors:</span>
<span class="sd">             attach()       open an existing vdata given its name or</span>
<span class="sd">                            reference number, or create a new one,</span>
<span class="sd">                            returning a VD instance</span>
<span class="sd">             create()       create a new vdata and define its structure,</span>
<span class="sd">                            returning a VD instance</span>

<span class="sd">           creating and initializing a simple vdata</span>
<span class="sd">             storedata()    create a single-field vdata and initialize</span>
<span class="sd">                            its values</span>

<span class="sd">           closing the interface</span>
<span class="sd">             end()          close the VS interface on the HDF file</span>

<span class="sd">           searching</span>
<span class="sd">             find()         get a vdata reference number given its name</span>
<span class="sd">             next()         get the reference number of the vdata following</span>
<span class="sd">                            a given one</span>

<span class="sd">           inquiry</span>
<span class="sd">             vdatainfo()    return info about all the vdatas in the</span>
<span class="sd">                            HDF file</span>

<span class="sd">  VD     The VD class describes a vdata. It encapsulates</span>
<span class="sd">         the VS instance to which the vdata belongs, and the vdata</span>
<span class="sd">         identifier.</span>

<span class="sd">         To instantiate a VD class, call the attach() or create()</span>
<span class="sd">         method of a VS class instance.</span>

<span class="sd">         methods:</span>
<span class="sd">           constructors</span>
<span class="sd">             attr()         create a VDAttr instance representing a</span>
<span class="sd">                            vdata attribute; &quot;dot notation&quot; can also be</span>
<span class="sd">                            used to access a vdata attribute</span>
<span class="sd">             field()        return a VDField instance representing a given</span>
<span class="sd">                            field of the vdata</span>

<span class="sd">           closing vdata</span>
<span class="sd">             detach()       end access to the vdata</span>

<span class="sd">           defining fields</span>
<span class="sd">             fdefine()      define the name, type and order of a new field</span>
<span class="sd">             setfields()    define the field names and field order for</span>
<span class="sd">                            the read() and write() methods; also used to</span>
<span class="sd">                            initialize the structure of a vdata previously</span>
<span class="sd">                            created with the VS.attach() method</span>

<span class="sd">           reading and writing</span>
<span class="sd">                            note: a vdata can be indexed and sliced like a</span>
<span class="sd">                            python sequence</span>

<span class="sd">             read()         return the values of a number of records</span>
<span class="sd">                            starting at the current record position</span>
<span class="sd">             seek()         reset the current record position</span>
<span class="sd">             seekend()      seek past the last record</span>
<span class="sd">             tell()         return the current record position</span>
<span class="sd">             write()        write a number of records starting at the</span>
<span class="sd">                            current record position</span>

<span class="sd">           inquiry</span>
<span class="sd">             attrinfo()     return info about all the vdata attributes</span>
<span class="sd">             fexist()       check if a vdata contains a given set of fields</span>
<span class="sd">             fieldinfo()    return info about all the vdata fields</span>
<span class="sd">             findattr()     locate an attribute, returning a VDAttr instance</span>
<span class="sd">                            if found</span>
<span class="sd">             inquire()      return info about the vdata</span>
<span class="sd">             sizeof()       return the size in bytes of one or more fields</span>

<span class="sd">  VDField  The VDField class represents a vdata field. It encapsulates</span>
<span class="sd">           the VD instance to which the field belongs, and the field</span>
<span class="sd">           index number.</span>

<span class="sd">           To instantiate a VDField, call the field() method of a VD class</span>
<span class="sd">           instance.</span>

<span class="sd">           methods:</span>
<span class="sd">             constructors:</span>
<span class="sd">               attr()       return a VDAttr instance representing an</span>
<span class="sd">                            attribute of the field; &quot;dot notation&quot;</span>
<span class="sd">                            can also be used to get/set an attribute.</span>

<span class="sd">             inquiry</span>
<span class="sd">               attrinfo()   return info about all the field attributes</span>
<span class="sd">               find()       locate an attribute, returning a VDAttr</span>
<span class="sd">                            instance if found</span>

<span class="sd">  VDAttr   The VDAttr class encapsulates methods used to set and query</span>
<span class="sd">           attributes defined at the level either of the vdata or the</span>
<span class="sd">           vdata field.</span>

<span class="sd">           To create an instance of this class, call the attr() or</span>
<span class="sd">           findattr() methods of a VD instance (for vdata attributes),</span>
<span class="sd">           or call the attr() or find() methods of a VDField instance</span>
<span class="sd">           (for field attributes).</span>

<span class="sd">           methods:</span>
<span class="sd">             get / set</span>
<span class="sd">               get()        get the attribute value</span>
<span class="sd">               set()        set the attribute value</span>

<span class="sd">             info</span>
<span class="sd">               info()       retrieve info about the attribute</span>

<span class="sd">Data types</span>
<span class="sd">----------</span>
<span class="sd">Data types come into play when first defining vdata fields and attributes,</span>
<span class="sd">and later when querying the definition of those fields and attributes.</span>
<span class="sd">Data types are specified using the symbolic constants defined inside the</span>
<span class="sd">HC class of the HDF module.</span>

<span class="sd">- CHAR and CHAR8 (equivalent): an 8-bit character.</span>
<span class="sd">- UCHAR, UCHAR8 and UINT8 (equivalent): unsigned 8-bit values (0 to 255)</span>
<span class="sd">- INT8:    signed 8-bit values (-128 to 127)</span>
<span class="sd">- INT16:   signed 16-bit values</span>
<span class="sd">- UINT16:  unsigned 16 bit values</span>
<span class="sd">- INT32:   signed 32 bit values</span>
<span class="sd">- UINT32:  unsigned 32 bit values</span>
<span class="sd">- FLOAT32: 32 bit floating point values (C floats)</span>
<span class="sd">- FLOAT64: 64 bit floating point values (C doubles)</span>

<span class="sd">There is no explicit &quot;string&quot; type. To simulate a string, set the field or</span>
<span class="sd">attribute type to CHAR, and set the field or attribute &quot;order&quot; to</span>
<span class="sd">a value of &#39;n&#39; &gt; 1. This creates and &quot;array of characters&quot;, close</span>
<span class="sd">to a string (except that strings will always be of length &#39;n&#39;, right-padded</span>
<span class="sd">with spaces if necessary).</span>

<span class="sd">Attribute access: low and high level</span>
<span class="sd">------------------------------------</span>
<span class="sd">The VS API allow setting attributes on vdatas and vdata fields. Attributes</span>
<span class="sd">can be of many types (int, float, char) of different bit lengths (8, 16, 32,</span>
<span class="sd">64 bits), and can be single or multi-valued. Values of a multi-valued</span>
<span class="sd">attribute must all be of the same type.</span>

<span class="sd">Attributes can be set and queried in two different ways. First, given a</span>
<span class="sd">VD instance (describing a vdata object) or a VDField instance (describing a</span>
<span class="sd">vdata field), the attr() method of that instance is called to create a</span>
<span class="sd">VDAttr instance representing the wanted attribute (possibly non existent).</span>
<span class="sd">The set() method of this VDAttr instance is then called to define the</span>
<span class="sd">attribute value, creating it if it does not already exist. The get() method</span>
<span class="sd">returns the current attribute value. Here is an example.</span>

<span class="sd">  &gt;&gt;&gt; from pyhdf.HDF import *</span>
<span class="sd">  &gt;&gt;&gt; from pyhdf.VS import *</span>
<span class="sd">  &gt;&gt;&gt; f = HDF(&#39;test.hdf&#39;, HC.WRITE) # Open file &#39;test.hdf&#39; in write mode</span>
<span class="sd">  &gt;&gt;&gt; vs = f.vstart()            # init vdata interface</span>
<span class="sd">  &gt;&gt;&gt; vd = vs.attach(&#39;vtest&#39;, 1) # attach vdata &#39;vtest&#39; in write mode</span>
<span class="sd">  &gt;&gt;&gt; attr = vd.attr(&#39;version&#39;)  # prepare to define the &#39;version&#39; attribute</span>
<span class="sd">                                 # on the vdata</span>
<span class="sd">  &gt;&gt;&gt; attr.set(HC.CHAR8,&#39;1.0&#39;)   # set attribute &#39;version&#39; to string &#39;1.0&#39;</span>
<span class="sd">  &gt;&gt;&gt; print(attr.get())           # get and print attribute value</span>
<span class="sd">  &gt;&gt;&gt; fld  = vd.field(&#39;fld1&#39;)    # obtain a field instance for field &#39;fld1&#39;</span>
<span class="sd">  &gt;&gt;&gt; attr = fld.attr(&#39;range&#39;)   # prepare to define attribute &#39;range&#39; on</span>
<span class="sd">                                 # this field</span>
<span class="sd">  &gt;&gt;&gt; attr.set(HC.INT32,(-10, 15)) # set attribute &#39;range&#39; to a pair of ints</span>
<span class="sd">  &gt;&gt;&gt; print(attr.get())             # get and print attribute value</span>

<span class="sd">  &gt;&gt;&gt; vd.detach()                # &quot;close&quot; the vdata</span>
<span class="sd">  &gt;&gt;&gt; vs.end()                   # terminate the vdata interface</span>
<span class="sd">  &gt;&gt;&gt; f.close()                  # close the HDF file</span>

<span class="sd">The second way consists of setting/querying an attribute as if it were a</span>
<span class="sd">normal python class attribute, using the usual dot notation. Above example</span>
<span class="sd">then becomes:</span>

<span class="sd">  &gt;&gt;&gt; from pyhdf.HDF import *</span>
<span class="sd">  &gt;&gt;&gt; from pyhdf.VS import *</span>
<span class="sd">  &gt;&gt;&gt; f = HDF(&#39;test.hdf&#39;, HC.WRITE) # Open file &#39;test.hdf&#39; in write mode</span>
<span class="sd">  &gt;&gt;&gt; vs = f.vstart()            # init vdata interface</span>
<span class="sd">  &gt;&gt;&gt; vd = vs.attach(&#39;vtest&#39;, 1) # attach vdata &#39;vtest&#39; in write mode</span>
<span class="sd">  &gt;&gt;&gt; vd.version = &#39;1.0&#39;         # create vdata attribute &#39;version&#39;,</span>
<span class="sd">                                 # setting it to string &#39;1.0&#39;</span>
<span class="sd">  &gt;&gt;&gt; print(vd.version)           # print attribute value</span>
<span class="sd">  &gt;&gt;&gt; fld  = vd.field(&#39;fld1&#39;)    # obtain a field instance for field &#39;fld1&#39;</span>
<span class="sd">  &gt;&gt;&gt; fld.range = (-10, 15)      # create field attribute &#39;range&#39;, setting</span>
<span class="sd">                                 # it to the pair of ints (-10, 15)</span>
<span class="sd">  &gt;&gt;&gt; print(fld.range)            # print attribute value</span>
<span class="sd">  &gt;&gt;&gt; vd.detach()                # &quot;close&quot; the vdata</span>
<span class="sd">  &gt;&gt;&gt; vs.end()                   # terminate the vdata interface</span>
<span class="sd">  &gt;&gt;&gt; f.close()                  # close the HDF file</span>

<span class="sd">Note how the dot notation greatly simplifies and clarifies the code.</span>
<span class="sd">Some latitude is however lost by manipulating attributes in that way,</span>
<span class="sd">because the pyhdf package, not the programmer, is then responsible of</span>
<span class="sd">setting the attribute type. The attribute type is chosen to be one of:</span>

<span class="sd">  =========== ====================================</span>
<span class="sd">  HC.CHAR8    if the attribute value is a string</span>
<span class="sd">  HC.INT32    if all attribute values are integers</span>
<span class="sd">  HC.FLOAT64  otherwise</span>
<span class="sd">  =========== ====================================</span>

<span class="sd">The first way of handling attribute values must be used if one wants to</span>
<span class="sd">define an attribute of any other type (for ex. 8 or 16 bit integers,</span>
<span class="sd">signed or unsigned). Also, only a VDAttr instance gives access to attribute</span>
<span class="sd">info, through its info() method.</span>

<span class="sd">However, accessing HDF attributes as if they were python attributes raises</span>
<span class="sd">an important issue. There must exist a way to assign generic attributes</span>
<span class="sd">to the python objects without requiring those attributes to be converted</span>
<span class="sd">to HDF attributes. pyhdf uses the following rule: an attribute whose name</span>
<span class="sd">starts with an underscore (&#39;_&#39;) is either a &quot;predefined&quot; attribute</span>
<span class="sd">(see below) or a standard python attribute. Otherwise, the attribute</span>
<span class="sd">is handled as an HDF attribute. Also, HDF attributes are not stored inside</span>
<span class="sd">the object dictionary: the python dir() function will not list them.</span>

<span class="sd">Attribute values can be updated, but it is illegal to try to change the</span>
<span class="sd">value type, or the attribute order (number of values). This is important</span>
<span class="sd">for attributes holding string values. An attribute initialized with an</span>
<span class="sd">&#39;n&#39; character string is simply a character attribute of order &#39;n&#39; (eg a</span>
<span class="sd">character array of length &#39;n&#39;). If &#39;vd&#39; is a vdata and we initialize its</span>
<span class="sd">&#39;a1&#39; attribute as &#39;vd.a1 = &quot;abcdef&quot;&#39;, then a subsequent update attempt</span>
<span class="sd">like &#39;vd.a1 = &quot;12&quot;&#39; will fail, because we then try to change the order</span>
<span class="sd">of the attribute (from 6 to 2). It is mandatory to keep the length of string</span>
<span class="sd">attributes constant. Examples below show simple ways how this can be done.</span>

<span class="sd">Predefined attributes</span>
<span class="sd">---------------------</span>
<span class="sd">The VD and VDField classes support predefined attributes to get (and</span>
<span class="sd">occasionnaly set) attribute values easily, without having to call a</span>
<span class="sd">class method. The names of predefined attributes all start with an</span>
<span class="sd">underscore (&#39;_&#39;).</span>

<span class="sd">In the following tables, the RW column holds an X if the attribute</span>
<span class="sd">is read/write. See the HDF User s guide for details about more</span>
<span class="sd">&quot;exotic&quot; topics like &quot;class&quot;, &quot;faked vdata&quot; and &quot;tag&quot;.</span>

<span class="sd">  VD predefined attributes</span>

<span class="sd">    =========== ==  ========================== =============================</span>
<span class="sd">    name        RW  description                C library routine</span>
<span class="sd">    =========== ==  ========================== =============================</span>
<span class="sd">    _class      X   class name                 VSgetclass/VSsetclass</span>
<span class="sd">    _fields         list of field names        VSgetfields</span>
<span class="sd">    _interlace  X   interlace mode             VSgetinterlace/VSsetinterlace</span>
<span class="sd">    _isattr         true if vdata is &quot;faked&quot;   VSisattr</span>
<span class="sd">                    by HDF to hold attributes</span>
<span class="sd">    _name       X   name of the vdata          VSgetname/VSsetname</span>
<span class="sd">    _nattrs         number of attributes       VSfnattrs</span>
<span class="sd">    _nfields        number of fields           VFnfields</span>
<span class="sd">    _nrecs          number of records          VSelts</span>
<span class="sd">    _recsize        record size (bytes)        VSQueryvsize</span>
<span class="sd">    _refnum         reference number           VSQueryref</span>
<span class="sd">    _tag            vdata tag                  VSQuerytag</span>
<span class="sd">    _tnattrs        total number of vdata and  VSnattrs</span>
<span class="sd">                    field attributes</span>
<span class="sd">    =========== ==  ========================== =============================</span>

<span class="sd">  VDField predefined attributes</span>

<span class="sd">    =========== ==  ========================== =============================</span>
<span class="sd">    name        RW  description                C library routine</span>
<span class="sd">    =========== ==  ========================== =============================</span>
<span class="sd">    _esize          external size (bytes)      VFfieldesize</span>
<span class="sd">    _index          index number               VSfindex</span>
<span class="sd">    _isize          internal size (bytes)      VFfieldisize</span>
<span class="sd">    _name           name                       VFfieldname</span>
<span class="sd">    _nattrs         number of attributes       VSfnattrs</span>
<span class="sd">    _order          order (number of values)   VFfieldorder</span>
<span class="sd">    _type           field type (HC.xxx)        VFfieldtype</span>
<span class="sd">    =========== ==  ========================== =============================</span>


<span class="sd">Record access: low and high level</span>
<span class="sd">---------------------------------</span>
<span class="sd">vdata records can be read and written in two different ways. The first one</span>
<span class="sd">consists of calling the basic I/O methods of the vdata:</span>

<span class="sd">- seek() to set the current record position, if necessary;</span>
<span class="sd">- read() to retrieve a given number of records from that position;</span>
<span class="sd">- write() to write a given number of records starting at</span>
<span class="sd">  that position</span>

<span class="sd">A second, higher level way, lets one see a vdata similarly to a python</span>
<span class="sd">sequence, and access its contents using the familiar indexing and slicing</span>
<span class="sd">notation in square brackets. Reading and writing a vdata as if it were a</span>
<span class="sd">python sequence may often look simpler, and improve code legibility.</span>

<span class="sd">Here are some examples of how a vdata &#39;vd&#39; holding 3 fields could be read.</span>

<span class="sd">  &gt;&gt;&gt; print(vd[0])         # print record 0</span>
<span class="sd">  &gt;&gt;&gt; print(vd[-1])        # print last record</span>
<span class="sd">  &gt;&gt;&gt; print(vd[2:])        # print records 2 and those that follow</span>
<span class="sd">  &gt;&gt;&gt; print(vd[:])         # print all records</span>
<span class="sd">  &gt;&gt;&gt; print(vd[:,0])       # print field 0 of all records</span>
<span class="sd">  &gt;&gt;&gt; print(vd[:3,:2])     # print first 2 fields of first 3 records</span>

<span class="sd">As the above examples show, the usual python rules are obeyed regarding</span>
<span class="sd">the interpretation of indexing and slicing values. Note that the vdata</span>
<span class="sd">fields can be indexed and sliced, not only the records. The setfields()</span>
<span class="sd">method can also be used to select a subset to the vdata fields</span>
<span class="sd">(setfields() also let you reorder the fields). When the vdata is</span>
<span class="sd">indexed (as opposed to being sliced), a single record is returned as a list</span>
<span class="sd">of values. When the vdata is sliced, a list of records is</span>
<span class="sd">always returned (thus a 2-level list), even if the slice contains only</span>
<span class="sd">one record.</span>

<span class="sd">A vdata can also be written similarly to a python sequence. When indexing</span>
<span class="sd">the vdata (as opposed to slicing it), a single record must be assigned,</span>
<span class="sd">and the record must be given as a sequence of values. It is legal to use</span>
<span class="sd">as an index the current number of records in the vdata: the record is then</span>
<span class="sd">appended to the vdata. When slicing the vdata, the records assigned to the</span>
<span class="sd">slice must always be given as a list of records, even</span>
<span class="sd">if only one record is assigned. Also, the number of records assigned must</span>
<span class="sd">always match the width of the slice, except if the slice includes or goes</span>
<span class="sd">past the last record of the vdata. In that case, the number of records</span>
<span class="sd">assigned can exceed the width of the slice, and the extra records are</span>
<span class="sd">appended to the vdata. So, to append records to vdata &#39;vd&#39;, simply</span>
<span class="sd">assign records to the slice &#39;vd[vd._nrecs:]&#39;. Note that, even if the</span>
<span class="sd">&#39;field&#39; dimension can be specified in the left-hand side expression,</span>
<span class="sd">there is no real interest in doing so, since all fields must</span>
<span class="sd">be specified when assigning a record to the vdata: it is an error to</span>
<span class="sd">try to assign just a few of the fields.</span>

<span class="sd">For example, given a vdata &#39;vd&#39; holding 5 records, and lists &#39;reca&#39;,</span>
<span class="sd">&#39;recb&#39;, etc, holding record values::</span>

<span class="sd">        vd[0] = reca              # updates record 0</span>
<span class="sd">        vd[0,:] = reca            # specifying fields is OK, but useless</span>
<span class="sd">        vd[0,1:] = reca[1:]       # error: all fields must be assigned</span>
<span class="sd">        vd[1] = [recb, recc]      # error: only one record allowed</span>
<span class="sd">        vd[5] = recc              # append one record</span>
<span class="sd">        vd[1:3] = [reca,recb]     # updates second and third record</span>
<span class="sd">        vd[1:4] = [reca, recb]    # error: 3 records needed</span>
<span class="sd">        vd[5:] = [reca,recb]      # appends 2 records to the vdata</span>
<span class="sd">        vd[4:] = [reca, recb]     # updates last record, append one</span>



<span class="sd">Programming models</span>
<span class="sd">------------------</span>

<span class="sd">Creating and initializing a new vdata</span>
<span class="sd">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="sd">The following code can serve as a model for the creation and</span>
<span class="sd">initialization of a new vdata. It implements the INVENTORY example</span>
<span class="sd">described in the &quot;Introduction&quot; section::</span>

<span class="sd">    from pyhdf.HDF import *</span>
<span class="sd">    from pyhdf.VS import *</span>

<span class="sd">    # Open HDF file and initialize the VS interface</span>
<span class="sd">    f = HDF(&#39;inventory.hdf&#39;,    # Open file &#39;inventory.hdf&#39; in write mode</span>
<span class="sd">            HC.WRITE|HC.CREATE) # creating it if it does not exist</span>
<span class="sd">    vs = f.vstart()             # init vdata interface</span>

<span class="sd">    # Create vdata and define its structure</span>
<span class="sd">    vd = vs.create(             # create a new vdata</span>
<span class="sd">                   &#39;INVENTORY&#39;, # name of the vdata</span>
<span class="sd">                                # fields of the vdata follow</span>
<span class="sd">               ((&#39;partid&#39;,HC.CHAR8, 5),       # 5 char string</span>
<span class="sd">                (&#39;description&#39;,HC.CHAR8, 10), # 10 char string field</span>
<span class="sd">                (&#39;qty&#39;,HC.INT16, 1),          # 1 16 bit int field</span>
<span class="sd">                (&#39;wght&#39;,HC.FLOAT32, 1),       # 1 32 bit float</span>
<span class="sd">                (&#39;price&#39;,HC.FLOAT32,1)        # 1 32 bit float</span>
<span class="sd">               ))         # 5 fields allocated in the vdata</span>

<span class="sd">    # Set attributes on the vdata and its fields</span>
<span class="sd">    vd.field(&#39;wght&#39;).unit = &#39;lb&#39;</span>
<span class="sd">    vd.field(&#39;price&#39;).unit = &#39;$&#39;</span>
<span class="sd">    # In order to be able to update a string attribute, it must</span>
<span class="sd">    # always be set to the same length. This sets &#39;status&#39; to a 20</span>
<span class="sd">    # char long, left-justified string, padded with spaces on the right.</span>
<span class="sd">    vd.status = &quot;%-20s&quot; % &#39;phase 1 done&#39;</span>

<span class="sd">    # Store records</span>
<span class="sd">    vd.write((                # write 3 records</span>
<span class="sd">              (&#39;Q1234&#39;, &#39;bolt&#39;,12, 0.01, 0.05),   # record 1</span>
<span class="sd">              (&#39;B5432&#39;, &#39;brush&#39;, 10, 0.4, 4.25),  # record 2</span>
<span class="sd">              (&#39;S7613&#39;, &#39;scissor&#39;, 2, 0.2, 3.75)  # record 3</span>
<span class="sd">              ))</span>
<span class="sd">    vd.detach()               # &quot;close&quot; the vdata</span>

<span class="sd">    vs.end()                  # terminate the vdata interface</span>
<span class="sd">    f.close()                 # close the HDF file</span>


<span class="sd">Note that is mandatory to always write whole records to the vdata.</span>
<span class="sd">Note also the comments about the initialization of the &#39;status&#39;</span>
<span class="sd">vdata attribute. We want to be able update this attribute (see</span>
<span class="sd">following examples). However, the VS API  prohibits changing an attribute</span>
<span class="sd">type when updating its value. Since the length (order) of an attribute</span>
<span class="sd">is part of its type, we make sure of setting the attribute to a length</span>
<span class="sd">long enough to accommodate the longest possible string we migh want to</span>
<span class="sd">assign to the attribute.</span>

<span class="sd">Appending records to a vdata</span>
<span class="sd">^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="sd">Appending records requires first seeking to the end of the vdata, to avoid</span>
<span class="sd">overwriting existing records. The following code can serve as a model. The</span>
<span class="sd">INVENTORY vdata created before is used::</span>

<span class="sd">    from pyhdf.HDF import *</span>
<span class="sd">    from pyhdf.VS import *</span>

<span class="sd">    f = HDF(&#39;inventory.hdf&#39;,         # Open &#39;inventory.hdf&#39; in write mode</span>
<span class="sd">            HC.WRITE|HC.CREATE)      # creating it if it does not exist</span>
<span class="sd">    vs = f.vstart()                  # init vdata interface</span>
<span class="sd">    vd = vs.attach(&#39;INVENTORY&#39;, 1)   # attach &#39;INVENTORY&#39; in write mode</span>

<span class="sd">    # Update the `status&#39; vdata attribute. The attribute length must not</span>
<span class="sd">    # change. We call the attribute info() method, which returns a list</span>
<span class="sd">    # where number of values (eg string length) is stored at index 2.</span>
<span class="sd">    # We then assign a left justified string of exactly that length.</span>
<span class="sd">    len = vd.attr(&#39;status&#39;).info()[2]</span>
<span class="sd">    vd.status = &#39;%-*s&#39; % (len, &#39;phase 2 done&#39;)</span>

<span class="sd">    vd[vd._nrecs:] = (                     # append 2 records</span>
<span class="sd">          (&#39;A4321&#39;, &#39;axe&#39;, 5, 1.5, 25),    # first record</span>
<span class="sd">          (&#39;C3214&#39;, &#39;cup&#39;, 100, 0.1, 3.25) # second record</span>
<span class="sd">                    )</span>
<span class="sd">    vd.detach()               # &quot;close&quot; the vdata</span>

<span class="sd">    vs.end()                  # terminate the vdata interface</span>
<span class="sd">    f.close()                 # close the HDF file</span>

<span class="sd">Note how, when updating the value of the &#39;status&#39; vdata attribute,</span>
<span class="sd">we take care of assigning a value of the same length as that of the</span>
<span class="sd">original value. Otherwise, the assignment would raise an exception.</span>
<span class="sd">Records are written by assigning the vdata through a slicing</span>
<span class="sd">expression, like a python sequence. By specifying the number of records</span>
<span class="sd">as the start of the slice, the records are appended to the vdata.</span>

<span class="sd">Updating records in a vdata</span>
<span class="sd">^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="sd">Updating requires seeking to the record to update before writing the new</span>
<span class="sd">records. New data will overwrite this record and all records that follow,</span>
<span class="sd">until a new seek is performed or the vdata is closed. Note that record</span>
<span class="sd">numbering starts at 0.</span>

<span class="sd">The following code can serve as a model. The INVENTORY vdata created</span>
<span class="sd">before is used::</span>

<span class="sd">    from pyhdf.HDF import *</span>
<span class="sd">    from pyhdf.VS import *</span>

<span class="sd">    f = HDF(&#39;inventory.hdf&#39;,         # Open &#39;inventory.hdf&#39; in write mode</span>
<span class="sd">            HC.WRITE|HC.CREATE)      # creating it if it does not exist</span>
<span class="sd">    vs = f.vstart()                  # init vdata interface</span>
<span class="sd">    vd = vs.attach(&#39;INVENTORY&#39;, 1)   # attach &#39;INVENTORY&#39; in write mode</span>

<span class="sd">    # Update the `status&#39; vdata attribute. The attribute length must not</span>
<span class="sd">    # change. We call the attribute info() method, which returns a list</span>
<span class="sd">    # where number of values (eg string length) is stored at index 2.</span>
<span class="sd">    # We then assign a left justified string of exactly that length.</span>
<span class="sd">    len = vd.attr(&#39;status&#39;).info()[2]</span>
<span class="sd">    vd.status = &#39;%-*s&#39; % (len, &#39;phase 3 done&#39;)</span>

<span class="sd">    # Update record at index 1 (second record)</span>
<span class="sd">    vd[1]  = (&#39;Z4367&#39;, &#39;surprise&#39;, 10, 3.1, 44.5)</span>
<span class="sd">    # Update record at index 4, and all those that follow</span>
<span class="sd">    vd[4:] = (</span>
<span class="sd">              (&#39;QR231&#39;, &#39;toy&#39;, 12, 2.5, 45),</span>
<span class="sd">              (&#39;R3389&#39;, &#39;robot&#39;, 3, 45, 2000)</span>
<span class="sd">              )</span>
<span class="sd">    vd.detach()               # &quot;close&quot; the vdata</span>
<span class="sd">    vs.end()                  # terminate the vdata interface</span>
<span class="sd">    f.close()                 # close the HDF file</span>

<span class="sd">Reading a vdata</span>
<span class="sd">^^^^^^^^^^^^^^^</span>
<span class="sd">The following example shows how read the vdata attributes and sequentially</span>
<span class="sd">maneuver through its records. Note how we use the exception mechanism</span>
<span class="sd">to break out of the reading loop when we reach the end of the vdata::</span>

<span class="sd">    from pyhdf.HDF import *</span>
<span class="sd">    from pyhdf.VS import *</span>

<span class="sd">    f = HDF(&#39;inventory.hdf&#39;)         # open &#39;inventory.hdf&#39; in read mode</span>
<span class="sd">    vs = f.vstart()                  # init vdata interface</span>
<span class="sd">    vd = vs.attach(&#39;INVENTORY&#39;)      # attach &#39;INVENTORY&#39; in read mode</span>

<span class="sd">    # Display some vdata attributes</span>
<span class="sd">    print &quot;status:&quot;, vd.status</span>
<span class="sd">    print &quot;vdata: &quot;, vd._name        # predefined attribute: vdata name</span>
<span class="sd">    print &quot;nrecs: &quot;, vd._nrecs       # predefined attribute:  num records</span>

<span class="sd">    # Display value of attribute &#39;unit&#39; for all fields on which</span>
<span class="sd">    # this attribute is set</span>
<span class="sd">    print &quot;units: &quot;,</span>
<span class="sd">    for fieldName in vd._fields:     # loop over all field names</span>
<span class="sd">        try:</span>
<span class="sd">            # instantiate field and obtain value of attribute &#39;unit&#39;</span>
<span class="sd">            v = vd.field(fieldName).unit</span>
<span class="sd">            print &quot;%s: %s&quot; % (fieldName, v),</span>
<span class="sd">        except:                      # no &#39;unit&#39; attribute: ignore</span>
<span class="sd">            pass</span>
<span class="sd">    print &quot;&quot;</span>
<span class="sd">    print &quot;&quot;</span>

<span class="sd">    # Display table header.</span>
<span class="sd">    header = &quot;%-7s %-12s %3s %4s %8s&quot; % tuple(vd._fields)</span>
<span class="sd">    print &quot;-&quot; * len(header)</span>
<span class="sd">    print header</span>
<span class="sd">    print &quot;-&quot; * len(header)</span>

<span class="sd">    # Loop over the vdata records, displaying each record as a table row.</span>
<span class="sd">    # Current record position is 0 after attaching the vdata.</span>
<span class="sd">    while 1:</span>
<span class="sd">        try:</span>
<span class="sd">            rec = vd.read()       # read next record</span>
<span class="sd">            # equivalent to:</span>
<span class="sd">          # rec = vd[vd.tell()]</span>
<span class="sd">            print &quot;%-7s %-12s %3d %4.1f %8.2f&quot; % tuple(rec[0])</span>
<span class="sd">        except HDF4Error:             # end of vdata reached</span>
<span class="sd">            break</span>

<span class="sd">    vd.detach()               # &quot;close&quot; the vdata</span>
<span class="sd">    vs.end()                  # terminate the vdata interface</span>
<span class="sd">    f.close()                 # close the HDF file</span>

<span class="sd">In the previous example, the reading/displaying loop can be greatly</span>
<span class="sd">simplified by rewriting it as follows::</span>

<span class="sd">    from pyhdf.HDF import *</span>
<span class="sd">    from pyhdf.VS import *</span>

<span class="sd">    f = HDF(&#39;inventory.hdf&#39;)         # open &#39;inventory.hdf&#39; in read mode</span>
<span class="sd">    vs = f.vstart()                  # init vdata interface</span>
<span class="sd">    vd = vs.attach(&#39;INVENTORY&#39;)      # attach &#39;INVENTORY&#39; in read mode</span>

<span class="sd">    ....</span>

<span class="sd">    # Read all records at once, and loop over the sequence.</span>
<span class="sd">    for rec in vd[:]:</span>
<span class="sd">        print &quot;%-7s %-12s %3d %4.1f %8.2f&quot; % tuple(rec)</span>

<span class="sd">    vd.detach()               # &quot;close&quot; the vdata</span>
<span class="sd">    ...</span>

<span class="sd">The indexing expression &#39;vd[:]&#39; returns the complete set of records,</span>
<span class="sd">which can then be looped over using a &#39;for&#39; statement. This style of loop</span>
<span class="sd">is quite clean, and should look very familiar to python adepts.</span>


<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">types</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">hdfext</span> <span class="k">as</span> <span class="n">_C</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">six</span>
<span class="kn">from</span> <span class="nn">.six.moves</span> <span class="kn">import</span> <span class="n">xrange</span>
<span class="kn">from</span> <span class="nn">.HC</span> <span class="kn">import</span> <span class="n">HC</span>
<span class="kn">from</span> <span class="nn">.error</span> <span class="kn">import</span> <span class="n">HDF4Error</span><span class="p">,</span> <span class="n">_checkErr</span>

<span class="c1"># List of names we want to be imported by an &quot;from pyhdf.VS import *&quot;</span>
<span class="c1"># statement</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;VS&#39;</span><span class="p">,</span> <span class="s1">&#39;VD&#39;</span><span class="p">,</span> <span class="s1">&#39;VDField&#39;</span><span class="p">,</span> <span class="s1">&#39;VDAttr&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="VS"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VS">[docs]</a><span class="k">class</span> <span class="nc">VS</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The VS class implements the VS (Vdata) interface applied to an</span>
<span class="sd">    HDF file.</span>
<span class="sd">    To instantiate a VS class, call the vstart() method of an</span>
<span class="sd">    HDF instance. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hinst</span><span class="p">):</span>
        <span class="c1"># Not to be called directly by the user.</span>
        <span class="c1"># A VS object is instantiated using the vstart()</span>
        <span class="c1"># method of an HDF instance.</span>

        <span class="c1"># Args:</span>
        <span class="c1">#    hinst    HDF instance</span>
        <span class="c1"># Returns:</span>
        <span class="c1">#    A VS instance</span>
        <span class="c1">#</span>
        <span class="c1"># C library equivalent : Vstart (rather: Vinitialize)</span>

        <span class="c1"># Private attributes:</span>
        <span class="c1">#  _hdf_inst:       HDF instance</span>

        <span class="c1"># Note: Vstart is just a macro; use &#39;Vinitialize&#39; instead</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">Vinitialize</span><span class="p">(</span><span class="n">hinst</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;VS&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s2">&quot;cannot initialize VS interface&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hdf_inst</span> <span class="o">=</span> <span class="n">hinst</span>


    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete the instance, first calling the end() method</span>
<span class="sd">        if not already done.          &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hdf_inst</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

<div class="viewcode-block" id="VS.end"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VS.end">[docs]</a>    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close the VS interface.</span>

<span class="sd">        Args::</span>

<span class="sd">          No argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          None</span>

<span class="sd">        C library equivalent : Vend</span>
<span class="sd">                                                &quot;&quot;&quot;</span>

        <span class="c1"># Note: Vend is just a macro; use &#39;Vfinish&#39; instead</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="n">_C</span><span class="o">.</span><span class="n">Vfinish</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hdf_inst</span><span class="o">.</span><span class="n">_id</span><span class="p">),</span>
                  <span class="s2">&quot;cannot terminate VS interface&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hdf_inst</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="n">vend</span> <span class="o">=</span> <span class="n">end</span>      <span class="c1"># For backward compatibility</span>

<div class="viewcode-block" id="VS.attach"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VS.attach">[docs]</a>    <span class="k">def</span> <span class="nf">attach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_name</span><span class="p">,</span> <span class="n">write</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Locate an existing vdata or create a new vdata in the HDF file,</span>
<span class="sd">        returning a VD instance.</span>

<span class="sd">        Args::</span>

<span class="sd">          num_name  Name or reference number of the vdata. An existing vdata</span>
<span class="sd">                    can be specified either through its reference number or</span>
<span class="sd">                    its name. Use -1 to create a new vdata.</span>
<span class="sd">                    Note that uniqueness is not imposed on vdatas names,</span>
<span class="sd">                    whereas refnums are guaranteed to be unique. Thus</span>
<span class="sd">                    knowledge of its reference number may be the only way</span>
<span class="sd">                    to get at a wanted vdata.</span>

<span class="sd">          write     Set to 0 to open the vdata in read-only mode,</span>
<span class="sd">                    set to 1 to open it in write mode</span>


<span class="sd">        Returns::</span>

<span class="sd">          VD instance representing the vdata</span>

<span class="sd">        C library equivalent : VSattach</span>

<span class="sd">        After creating a new vdata (num_name == -1), fields must be</span>
<span class="sd">        defined using method fdefine() of the VD instance, and those</span>
<span class="sd">        fields must be allocated to the vdata with method setfields().</span>
<span class="sd">        Same results can be achieved, but more simply, by calling the</span>
<span class="sd">        create() method of the VS instance.</span>
<span class="sd">                                                    &quot;&quot;&quot;</span>

        <span class="n">mode</span> <span class="o">=</span> <span class="n">write</span> <span class="ow">and</span> <span class="s1">&#39;w&#39;</span> <span class="ow">or</span> <span class="s1">&#39;r&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">num_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">num_name</span>
        <span class="n">vd</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSattach</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hdf_inst</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;attach&#39;</span><span class="p">,</span> <span class="n">vd</span><span class="p">,</span> <span class="s1">&#39;cannot attach vdata&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">VD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vd</span><span class="p">)</span></div>

<div class="viewcode-block" id="VS.create"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VS.create">[docs]</a>    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new vdata, setting its name and allocating</span>
<span class="sd">        its fields.</span>

<span class="sd">        Args::</span>

<span class="sd">          name     Name to assign to the vdata</span>
<span class="sd">          fields   Sequence of field definitions. Each field definition</span>
<span class="sd">                   is a sequence with the following elements in order:</span>

<span class="sd">                   - field name</span>
<span class="sd">                   - field type (one of HC.xxx constants)</span>
<span class="sd">                   - field order (number of values)</span>

<span class="sd">                   Fields are allocated to the vdata in the given order</span>


<span class="sd">        Returns::</span>

<span class="sd">          VD instance representing the created vdata</span>

<span class="sd">        Calling the create() method is equivalent to the following calls:</span>
<span class="sd">          - vd = attach(-1,1), to create a new vdata and open it in</span>
<span class="sd">                 write mode</span>
<span class="sd">          - vd._name = name, to set the vdata name</span>
<span class="sd">          - vd.fdefine(...), to define the name, type and order of</span>
<span class="sd">                 each field</span>
<span class="sd">          - vd.setfields(...), to allocate fields to the vdata</span>

<span class="sd">        C library equivalent : no equivalent</span>
<span class="sd">                                                      &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Create new vdata (-1), open in write mode (1)</span>
            <span class="n">vd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Set vdata name</span>
            <span class="n">vd</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="c1"># Define fields</span>
            <span class="n">allNames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">order</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
                <span class="n">vd</span><span class="o">.</span><span class="n">fdefine</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
                <span class="n">allNames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="c1"># Allocate fields to the vdata</span>
            <span class="n">vd</span><span class="o">.</span><span class="n">setfields</span><span class="p">(</span><span class="o">*</span><span class="n">allNames</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">vd</span>
        <span class="k">except</span> <span class="n">HDF4Error</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;error creating vdata (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">msg</span><span class="p">)</span></div>

<div class="viewcode-block" id="VS.find"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VS.find">[docs]</a>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vName</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the reference number of a vdata given its name.</span>
<span class="sd">        The vdata can then be opened (attached) by passing this</span>
<span class="sd">        reference number to the attach() method.</span>

<span class="sd">        Args::</span>

<span class="sd">          vName    Name of the vdata for which the reference number</span>
<span class="sd">                   is needed. vdatas names are not guaranteed to be</span>
<span class="sd">                   unique. When more than one vdata bear the same name,</span>
<span class="sd">                   find() will return the refnum of the first one founmd.</span>

<span class="sd">        Returns::</span>

<span class="sd">          vdata reference number. 0 is returned if the vdata does not exist.</span>

<span class="sd">        C library equivalent : VSfind</span>
<span class="sd">                                               &quot;&quot;&quot;</span>

        <span class="n">refNum</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSfind</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hdf_inst</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">vName</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s2">&quot;find&quot;</span><span class="p">,</span> <span class="n">refNum</span><span class="p">,</span> <span class="s2">&quot;cannot find vdata </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">vName</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">refNum</span></div>

<div class="viewcode-block" id="VS.next"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VS.next">[docs]</a>    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vRef</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the reference number of the vdata following a given</span>
<span class="sd">        vdata.</span>

<span class="sd">        Args::</span>

<span class="sd">          vRef   Reference number of the vdata preceding the one</span>
<span class="sd">                 we require. Set to -1 to get the first vdata in</span>
<span class="sd">                 the HDF file. Knowing its reference number,</span>
<span class="sd">                 the vdata can then be opened (attached) by passing this</span>
<span class="sd">                 reference number to the attach() method.</span>

<span class="sd">        Returns::</span>

<span class="sd">          Reference number of the vdata following the one given</span>
<span class="sd">          by argument vref</span>

<span class="sd">        An exception is raised if no vdata follows the one given by vRef.</span>

<span class="sd">        C library equivalent : VSgetid</span>
<span class="sd">                                               &quot;&quot;&quot;</span>

        <span class="n">num</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSgetid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hdf_inst</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">vRef</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;next&#39;</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="s1">&#39;cannot get next vdata&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">num</span></div>

<div class="viewcode-block" id="VS.vdatainfo"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VS.vdatainfo">[docs]</a>    <span class="k">def</span> <span class="nf">vdatainfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">listAttr</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return info about all the file vdatas.</span>

<span class="sd">        Args::</span>

<span class="sd">          listAttr   Set to 0 to ignore vdatas used to store attribute</span>
<span class="sd">                     values, 1 to list them (see the VD._isattr readonly</span>
<span class="sd">                     attribute)</span>

<span class="sd">        Returns::</span>

<span class="sd">          List of vdata descriptions. Each vdata is described as</span>
<span class="sd">          a 9-element tuple, composed of the following:</span>

<span class="sd">          - vdata name</span>
<span class="sd">          - vdata class</span>
<span class="sd">          - vdata reference number</span>
<span class="sd">          - vdata number of records</span>
<span class="sd">          - vdata number of fields</span>
<span class="sd">          - vdata number of attributes</span>
<span class="sd">          - vdata record size in bytes</span>
<span class="sd">          - vdata tag number</span>
<span class="sd">          - vdata interlace mode</span>


<span class="sd">        C library equivalent : no equivalent</span>
<span class="sd">                                                 &quot;&quot;&quot;</span>

        <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>      <span class="c1"># start at beginning</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nxtRef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">HDF4Error</span><span class="p">:</span>    <span class="c1"># no vdata left</span>
                <span class="k">break</span>
            <span class="c1"># Attach the vdata and check for an &quot;attribute&quot; vdata.</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">nxtRef</span>
            <span class="n">vdObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">listAttr</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">vdObj</span><span class="o">.</span><span class="n">_isattr</span><span class="p">:</span>
                <span class="c1"># Append a list of vdata properties.</span>
                <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">vdObj</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span>
                            <span class="n">vdObj</span><span class="o">.</span><span class="n">_class</span><span class="p">,</span>
                            <span class="n">vdObj</span><span class="o">.</span><span class="n">_refnum</span><span class="p">,</span>
                            <span class="n">vdObj</span><span class="o">.</span><span class="n">_nrecs</span><span class="p">,</span>
                            <span class="n">vdObj</span><span class="o">.</span><span class="n">_nfields</span><span class="p">,</span>
                            <span class="n">vdObj</span><span class="o">.</span><span class="n">_nattrs</span><span class="p">,</span>
                            <span class="n">vdObj</span><span class="o">.</span><span class="n">_recsize</span><span class="p">,</span>
                            <span class="n">vdObj</span><span class="o">.</span><span class="n">_tag</span><span class="p">,</span>
                            <span class="n">vdObj</span><span class="o">.</span><span class="n">_interlace</span><span class="p">))</span>
            <span class="n">vdObj</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">lst</span></div>

<div class="viewcode-block" id="VS.storedata"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VS.storedata">[docs]</a>    <span class="k">def</span> <span class="nf">storedata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldName</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">vName</span><span class="p">,</span> <span class="n">vClass</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create and initialize a single field vdata, returning</span>
<span class="sd">        the vdata reference number.</span>

<span class="sd">        Args::</span>

<span class="sd">          fieldName   Name of the single field in the vadata to create</span>
<span class="sd">          values      Sequence of values to store in the field;. Each value can</span>
<span class="sd">                      itself be a sequence, in which case the field will be</span>
<span class="sd">                      multivalued (all second-level sequences must be of</span>
<span class="sd">                      the same length)</span>
<span class="sd">          data_type   Values type (one of HC.xxx constants). All values</span>
<span class="sd">                      must be of the same type</span>
<span class="sd">          vName       Name of the vdata to create</span>
<span class="sd">          vClass      Vdata class (string)</span>


<span class="sd">        Returns::</span>

<span class="sd">          vdata reference number</span>

<span class="sd">        C library equivalent : VHstoredata / VHstoredatam</span>
<span class="sd">                                                &quot;&quot;&quot;</span>

        <span class="c1"># See if the field is multi-valued.</span>
        <span class="n">nrecs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># Replace input list with a flattened list.</span>
            <span class="n">newValues</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">el</span><span class="p">:</span>
                    <span class="n">newValues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">newValues</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">n_values</span> <span class="o">=</span> <span class="n">nrecs</span> <span class="o">*</span> <span class="n">order</span>
        <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">CHAR8</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="c1"># Allow values to be passed as a string.</span>
            <span class="c1"># Noop if a list is passed.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_values</span><span class="p">):</span>
                <span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">HC</span><span class="o">.</span><span class="n">UCHAR8</span><span class="p">,</span> <span class="n">HC</span><span class="o">.</span><span class="n">UINT8</span><span class="p">]:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">INT8</span><span class="p">:</span>
            <span class="c1"># SWIG refuses negative values here. We found that if we</span>
            <span class="c1"># pass them as byte values, it will work.</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int8</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_values</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">&amp;=</span> <span class="mh">0x7f</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span>
                    <span class="k">if</span> <span class="n">v</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="mi">256</span> <span class="o">-</span> <span class="n">v</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="mi">128</span>         <span class="c1"># -128 in 2s complement</span>
                <span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">INT16</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">UINT16</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">INT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">UINT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">FLOAT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">FLOAT64</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float64</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;storedata: illegal or unimplemented data_type&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_values</span><span class="p">):</span>
            <span class="n">buf</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">vd</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VHstoredata</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hdf_inst</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">fieldName</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
                                <span class="n">nrecs</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">vName</span><span class="p">,</span> <span class="n">vClass</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vd</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VHstoredatam</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hdf_inst</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">fieldName</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
                                <span class="n">nrecs</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">vName</span><span class="p">,</span> <span class="n">vClass</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;storedata&#39;</span><span class="p">,</span> <span class="n">vd</span><span class="p">,</span> <span class="s1">&#39;cannot create vdata&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vd</span></div></div>


<div class="viewcode-block" id="VD"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VD">[docs]</a><span class="k">class</span> <span class="nc">VD</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The VD class encapsulates the functionality of a vdata.</span>
<span class="sd">    To instantiate a VD class, call the attach() or the create()</span>
<span class="sd">    method of a VS class instance.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vsinst</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="c1"># This constructor is not intended to be called directly</span>
        <span class="c1"># by the user program. The attach() method of an</span>
        <span class="c1"># VS class instance should be called instead.</span>

        <span class="c1"># Arg:</span>
        <span class="c1">#  vsinst      VS instance from which the call is made</span>
        <span class="c1">#  id          vdata reference number</span>

        <span class="c1"># Private attributes:</span>
        <span class="c1">#  _vs_inst   VS instance to which the vdata belongs</span>
        <span class="c1">#  _id        vdata identifier</span>
        <span class="c1">#  _offset    current record offset</span>
        <span class="c1">#  _setfields last arg to setfields()</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">_vs_inst</span> <span class="o">=</span> <span class="n">vsinst</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setfields</span> <span class="o">=</span> <span class="kc">None</span>


    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Some vdata properties can be queried/set through the following</span>
<span class="sd">        attributes. Their names all start with an &quot;_&quot; to avoid</span>
<span class="sd">        clashes with user-defined attributes. Most are read-only.</span>
<span class="sd">        Only the _class, _fields, _interlace and _name can be modified.</span>
<span class="sd">        _fields and _interlace can only be set once.</span>

<span class="sd">        Name       RO  Description              C library routine</span>
<span class="sd">        -----      --  -----------------        -----------------</span>
<span class="sd">        _class         class name               VSgetclass</span>
<span class="sd">        _fields    X   field names              VSgetfields</span>
<span class="sd">        _interlace     interlace mode           VSgetinterlace</span>
<span class="sd">        _isattr    X   attribute vs real vdata  VSisattr</span>
<span class="sd">        _name          name                     VSgetname</span>
<span class="sd">        _nattrs    X   number of attributes     VSfnattrs</span>
<span class="sd">        _nfields   X   number of fields         VFnfields</span>
<span class="sd">        _nrecs     X   number of records        VSelts</span>
<span class="sd">        _recsize   X   record size              VSQueryvsize</span>
<span class="sd">        _refnum    X   reference number         VSQueryref</span>
<span class="sd">        _tag       X   tag                      VSQuerytag</span>
<span class="sd">        _tnattrs   X   total number of attr.    VSnattrs</span>

<span class="sd">                                                         &quot;&quot;&quot;</span>

        <span class="c1"># Check for a user defined attribute first.</span>
        <span class="n">att</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>   <span class="c1"># Then the attribute exists</span>
            <span class="k">return</span> <span class="n">att</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

        <span class="c1"># Check for a predefined attribute</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_class&quot;</span><span class="p">:</span>
            <span class="n">status</span><span class="p">,</span> <span class="n">nm</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSgetclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;_class&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;cannot get vdata class&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">nm</span>

        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_fields&quot;</span><span class="p">:</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">fields</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSgetfields</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;_fields&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot;cannot get vdata field names&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fields</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_interlace&quot;</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSgetinterlace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;_interlace&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="s2">&quot;cannot get vdata interlace mode&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mode</span>

        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_isattr&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSisattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_name&quot;</span><span class="p">:</span>
            <span class="n">status</span><span class="p">,</span> <span class="n">nm</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSgetname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;_name&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;cannot get vdata name&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">nm</span>

        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_nattrs&quot;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSfnattrs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># -1: vdata attributes</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s2">&quot;_nfields&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot;cannot retrieve number of attributes&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span>

        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_nfields&quot;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VFnfields</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s2">&quot;_nfields&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot;cannot retrieve number of fields&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span>

        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_nrecs&quot;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSelts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;_nrecs&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s1">&#39;cannot get vdata number of records&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span>

        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_recsize&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inquire</span><span class="p">()[</span><span class="mi">3</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_refnum&quot;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSQueryref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;refnum&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s1">&#39;cannot get reference number&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span>

        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_tag&quot;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSQuerytag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;_tag&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s1">&#39;cannot get tag&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span>

        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_tnattrs&quot;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSnattrs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;_tnattrs&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s1">&#39;execution error&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>

        <span class="c1"># A name starting with an underscore will be treated as</span>
        <span class="c1"># a standard python attribute, and as an HDF attribute</span>
        <span class="c1"># otherwise.</span>

        <span class="c1"># Forbid assigning to our predefined attributes</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;_fields&quot;</span><span class="p">,</span> <span class="s2">&quot;_isattr&quot;</span><span class="p">,</span> <span class="s2">&quot;_nattrs&quot;</span><span class="p">,</span> <span class="s2">&quot;_nfields&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;_nrecs&quot;</span><span class="p">,</span> <span class="s2">&quot;_recsize&quot;</span><span class="p">,</span> <span class="s2">&quot;_refnum&quot;</span><span class="p">,</span> <span class="s2">&quot;_tag&quot;</span><span class="p">,</span> <span class="s2">&quot;_tnattrs&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: read-only attribute&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

        <span class="c1"># Handle the 3 VS attributes: _class, _interlace</span>
        <span class="c1"># and _name. _interlace can only be set once.</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_class&quot;</span><span class="p">:</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSsetclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span>
                      <span class="s1">&#39;cannot set _class property&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_interlace&quot;</span><span class="p">:</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSsetinterlace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span>
                      <span class="s1">&#39;cannot set _interlace property&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_name&quot;</span><span class="p">:</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSsetname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span>
                      <span class="s1">&#39;cannot set _name property&#39;</span><span class="p">)</span>

        <span class="c1"># Try to set the attribute.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">):</span>

        <span class="c1"># This method is called when the vdata is read</span>
        <span class="c1"># like a Python sequence.</span>

        <span class="c1"># Parse the indexing expression.</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__buildStartCount</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="c1"># Reset current position if necessary.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">!=</span> <span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Get records. A negative count means that an index was used.</span>
        <span class="n">recs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="c1"># See if all the fields must be returned.</span>
        <span class="n">f0</span> <span class="o">=</span> <span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">f0</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">count</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nfields</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">recs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Return only a subset of the vdata fields.</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">f1</span> <span class="o">=</span> <span class="n">f0</span> <span class="o">+</span> <span class="n">count</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">recs</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">f0</span><span class="p">:</span><span class="n">f1</span><span class="p">])</span>

        <span class="c1"># If an index was used (not a slice), return the record as</span>
        <span class="c1"># a list, instead of returning it inside a 2-level list,</span>
        <span class="k">if</span> <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

        <span class="c1"># This method is called when the vdata is written</span>
        <span class="c1"># like a Python sequence.</span>
        <span class="c1">#</span>
        <span class="c1"># When indexing the vdata, &#39;data&#39; must specify exactly</span>
        <span class="c1"># one record, which must be specified as a sequence. If the index is</span>
        <span class="c1"># equal to the current number of records, the record</span>
        <span class="c1"># is appended to the vdata.</span>
        <span class="c1">#</span>
        <span class="c1"># When slicing the vdata, &#39;data&#39; must specify a list of records.</span>
        <span class="c1"># The number of records in the top level-list must match the width</span>
        <span class="c1"># of the slice, except if the slice extends past the end of the</span>
        <span class="c1"># vdata. In that case, extra records can be specified in the list,</span>
        <span class="c1"># which will be appended to the vdata. In other words,</span>
        <span class="c1"># to append records to vdata &#39;vd&#39;, assign records to</span>
        <span class="c1"># the slice &#39;vd[vd._nrecs:]&#39;.</span>
        <span class="c1">#</span>
        <span class="c1"># For ex., given a vdata &#39;vd&#39; holding 5 records, and lists</span>
        <span class="c1"># &#39;reca&#39;, &#39;recb&#39;, etc holding record values:</span>
        <span class="c1">#  vd[0] = reca              # updates record 0</span>
        <span class="c1">#  vd[1] = [recb, recc]      # error: only one record allowed</span>
        <span class="c1">#  vd[1:3] = [reca,recb]     # updates second and third record</span>
        <span class="c1">#  vd[1:4] = [reca, recb]   # error: 3 records needed</span>
        <span class="c1">#  vd[5:] = [reca,recb]      # appends 2 records to the vdata</span>

        <span class="c1"># Check that arg is a list.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;record(s) must be specified as a list&quot;</span><span class="p">)</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__buildStartCount</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">setitem</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Records cannot be partially written.</span>
        <span class="k">if</span> <span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">count</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nfields</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;each vdata field must be written&quot;</span><span class="p">)</span>

        <span class="c1"># If an index (as opposed to a slice) was applied to the</span>
        <span class="c1"># vdata, a single record must be passed. Since write() requires</span>
        <span class="c1"># a 2-level list, wrap this record inside a list.</span>
        <span class="k">if</span> <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nfields</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;record does not specify all fields&quot;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>
        <span class="c1"># A slice was used. The slice length must match the number of</span>
        <span class="c1"># records, except if the end of the slice equals the number</span>
        <span class="c1"># of records. Then, extra recors can be specified, which will</span>
        <span class="c1"># be appended to the vdata.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nrecs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;illegal number of records&quot;</span><span class="p">)</span>
        <span class="c1"># Reset current record position if necessary.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">!=</span> <span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Write records.</span>
        <span class="n">recs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete the instance, first calling the detach() method</span>
<span class="sd">        if not already done.          &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

<div class="viewcode-block" id="VD.detach"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VD.detach">[docs]</a>    <span class="k">def</span> <span class="nf">detach</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Terminate access to the vdata.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          None</span>

<span class="sd">        C library equivalent : VSdetach</span>
<span class="sd">                                              &quot;&quot;&quot;</span>

        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;detach&#39;</span><span class="p">,</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSdetach</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">),</span> <span class="s2">&quot;cannot detach vdata&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="VD.fdefine"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VD.fdefine">[docs]</a>    <span class="k">def</span> <span class="nf">fdefine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define a field. To initialize a newly created vdata with</span>
<span class="sd">        fields created with fdefine(), assign a tuple of field names</span>
<span class="sd">        to the _fields attribute or call the setfields() method.</span>

<span class="sd">        Args::</span>

<span class="sd">          name     field name</span>
<span class="sd">          type     field data type (one of HC.xxx)</span>
<span class="sd">          order    field order (number of values in the field)</span>

<span class="sd">        Returns::</span>

<span class="sd">          None</span>

<span class="sd">        C library equivalent : VSfdefine</span>
<span class="sd">                                            &quot;&quot;&quot;</span>

        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;fdefine&#39;</span><span class="p">,</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSfdefine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">order</span><span class="p">),</span>
                  <span class="s1">&#39;cannot define field&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="VD.setfields"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VD.setfields">[docs]</a>    <span class="k">def</span> <span class="nf">setfields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">fldNames</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define the name and order of the fields to access</span>
<span class="sd">        with the read() and write() methods.</span>

<span class="sd">        Args::</span>

<span class="sd">          fldNames  variable length argument specifying one or more</span>
<span class="sd">                    vdata field names</span>

<span class="sd">        Returns::</span>

<span class="sd">          None</span>

<span class="sd">        C library equivalent : VSsetfields</span>

<span class="sd">        setfields() indicates how to perform the matching between the vdata</span>
<span class="sd">        fields and the values passed to the write() method or returned</span>
<span class="sd">        by the read() method.</span>

<span class="sd">        For example, if the vdata contains fields &#39;a&#39;, &#39;b&#39; and &#39;c&#39; and</span>
<span class="sd">        a &quot;setfields(&#39;c&#39;,&#39;a&#39;)&quot; call is made,  read() will thereafter return</span>
<span class="sd">        for each record the values of field &#39;c&#39; and &#39;a&#39;, in that order.</span>
<span class="sd">        Field &#39;b&#39; will be ignored.</span>

<span class="sd">        When writing to a vdata, setfields() has a second usage. It is used</span>
<span class="sd">        to initialize the structure of the vdata, that is, the name and order</span>
<span class="sd">        of the fields that it will contain. The fields must have been</span>
<span class="sd">        previously defined by calls to the fdefine() method.</span>
<span class="sd">        Following that first call, setfields() can be called again to</span>
<span class="sd">        change the order in which the record values will be passed</span>
<span class="sd">        to the write() method. However, since it is mandatory to write</span>
<span class="sd">        whole records, subsequent calls to setfields() must specify every</span>
<span class="sd">        field name: only the field order can be changed.</span>

<span class="sd">                                                   &quot;&quot;&quot;</span>

        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;setfields&#39;</span><span class="p">,</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSsetfields</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fldNames</span><span class="p">)),</span>
                  <span class="s1">&#39;cannot execute&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setfields</span> <span class="o">=</span> <span class="n">fldNames</span>   <span class="c1"># remember for read/write routines</span></div>


<div class="viewcode-block" id="VD.field"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VD.field">[docs]</a>    <span class="k">def</span> <span class="nf">field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a VDField instance representing a field of the vdata.</span>

<span class="sd">        Args::</span>

<span class="sd">          name_index   name or index number of the field</span>

<span class="sd">        Returns::</span>

<span class="sd">          VDfield instance representing the field</span>

<span class="sd">        C library equivalent : no equivalent</span>
<span class="sd">                                                       &quot;&quot;&quot;</span>

        <span class="c1"># Transform a name to an index number</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_index</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">status</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSfindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">name_index</span><span class="p">)</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s2">&quot;illegal field name: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">name_index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VFnfields</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s1">&#39;cannot execute&#39;</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">name_index</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;field: illegal index number&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">VDField</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="VD.seek"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VD.seek">[docs]</a>    <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recIndex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Seek to the beginning of the record identified by its</span>
<span class="sd">        record index. A succeeding read will load this record in</span>
<span class="sd">        memory.</span>

<span class="sd">        Args::</span>

<span class="sd">          recIndex  index of the record in the vdata; numbering</span>
<span class="sd">                    starts at 0. Legal values range from 0</span>
<span class="sd">                    (start of vdata) to the current number of</span>
<span class="sd">                    records (at end of vdata).</span>

<span class="sd">        Returns::</span>

<span class="sd">          record index</span>

<span class="sd">        An exception is raised if an attempt is made to seek beyond the</span>
<span class="sd">        last record.</span>

<span class="sd">        The C API prohibits seeking past the next-to-last record,</span>
<span class="sd">        forcing one to read the last record to advance to the end</span>
<span class="sd">        of the vdata. The python API removes this limitation.</span>

<span class="sd">        Seeking to the end of the vdata can also be done by calling</span>
<span class="sd">        method ``seekend()``.</span>

<span class="sd">        C library equivalent : VSseek</span>
<span class="sd">                                                &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">recIndex</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nrecs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">recIndex</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nrecs</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seekend</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;attempt to seek past last record&quot;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSseek</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">recIndex</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;seek&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s1">&#39;cannot seek&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">n</span>
        <span class="k">return</span> <span class="n">n</span></div>

<div class="viewcode-block" id="VD.seekend"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VD.seekend">[docs]</a>    <span class="k">def</span> <span class="nf">seekend</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the current record position past the last vdata record.</span>
<span class="sd">        Subsequent write() calls will append records to the vdata.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          index of the last record plus 1</span>

<span class="sd">        C library equivalent : no equivalent</span>
<span class="sd">                                                 &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Seek to the next-to-last record position</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nrecs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>       <span class="c1"># updates _offset</span>
            <span class="c1"># Read last record, ignoring values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                         <span class="c1"># updates _offset</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nrecs</span>
        <span class="k">except</span> <span class="n">HDF4Error</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;seekend: cannot execute&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VD.tell"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VD.tell">[docs]</a>    <span class="k">def</span> <span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return current record position in the vdata.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          current record position; 0 is at start of vdata.</span>

<span class="sd">        C library equivalent : no equivalent</span>
<span class="sd">                                             &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span></div>

<div class="viewcode-block" id="VD.read"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VD.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nRec</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve the values of a number of records, starting</span>
<span class="sd">        at the current record position. The current record position</span>
<span class="sd">        is advanced by the number of records read. Current position</span>
<span class="sd">        is 0 after &quot;opening&quot; the vdata with the attach() method.</span>

<span class="sd">        Args::</span>

<span class="sd">          nRec    number of records to read</span>


<span class="sd">        Returns::</span>

<span class="sd">          2-level list. First level is a sequence of records,</span>
<span class="sd">          second level gives the sequence of values for each record.</span>
<span class="sd">          The values returned for each record are those of the fields</span>
<span class="sd">          specified in the last call to method setfields(), in that</span>
<span class="sd">          order. The complete vdata field set is returned if</span>
<span class="sd">          setfields() has not been called.</span>

<span class="sd">        An exception is raised if the current record position is</span>
<span class="sd">        already at the end of the vdata when read() is called. This</span>
<span class="sd">        exception can be caught as an &quot;end of vdata&quot; indication to</span>
<span class="sd">        exit a loop which scans each record of the vdata. Otherwise,</span>
<span class="sd">        the number of records to be read is lowered to the number of</span>
<span class="sd">        records remaining in the vdata, if that number is less than</span>
<span class="sd">        the number asked for by parameter &#39;nRec&#39;. Setting &#39;nRec&#39; to</span>
<span class="sd">        an arbitrarily large value can thus be used to retrieve the</span>
<span class="sd">        remaining records in the vdata.</span>

<span class="sd">        C library equivalent : VSread</span>
<span class="sd">                                                       &quot;&quot;&quot;</span>
        <span class="c1"># Validate number of records to read vs the current offset.</span>
        <span class="c1"># Return &quot;end of vdata&quot; exception if already at end of vdata</span>
        <span class="c1"># otherwise &quot;clip&quot; the number of records if it exceeds the</span>
        <span class="c1"># number of remaining records in the vdata.</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nrecs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;end of vdata reached&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+</span> <span class="n">nRec</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">nRec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+</span> <span class="n">nRec</span> <span class="o">-</span> <span class="n">n</span>

        <span class="n">fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setfields</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span>
        <span class="n">nFields</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>
        <span class="n">fieldList</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;read&#39;</span><span class="p">,</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSsetfields</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">fieldList</span><span class="p">),</span>
                  <span class="s1">&#39;error defining fields to read&#39;</span><span class="p">)</span>

        <span class="c1"># Allocate a buffer to store the packed records.</span>
        <span class="n">bufSize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizeof</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="o">*</span> <span class="n">nRec</span>
        <span class="n">bigBuf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">bufSize</span><span class="p">)</span>

        <span class="c1"># Read records</span>
        <span class="n">nRead</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSread</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">bigBuf</span><span class="p">,</span> <span class="n">nRec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>   <span class="c1"># 0: FULL_INTERLACE</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;read&#39;</span><span class="p">,</span> <span class="n">nRead</span><span class="p">,</span> <span class="s1">&#39;read error&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+=</span> <span class="n">nRec</span>

        <span class="c1"># Allocate an array to store a pointer to the field buffer.</span>
        <span class="n">fldArr</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">new_array_voidp</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Initialize return value</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">numRec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nRead</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">numFld</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nFields</span><span class="p">):</span>
                <span class="n">v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="c1"># Unpack each field in turn.</span>
        <span class="k">for</span> <span class="n">numFld</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nFields</span><span class="p">):</span>
            <span class="n">fld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="n">numFld</span><span class="p">])</span>
            <span class="n">data_type</span> <span class="o">=</span> <span class="n">fld</span><span class="o">.</span><span class="n">_type</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">fld</span><span class="o">.</span><span class="n">_order</span>
            <span class="n">n_values</span> <span class="o">=</span> <span class="n">order</span> <span class="o">*</span> <span class="n">nRead</span>

            <span class="c1"># Allocate a buffer to store the field values.</span>
            <span class="k">if</span> <span class="n">data_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">HC</span><span class="o">.</span><span class="n">CHAR8</span><span class="p">,</span> <span class="n">HC</span><span class="o">.</span><span class="n">UCHAR8</span><span class="p">,</span> <span class="n">HC</span><span class="o">.</span><span class="n">UINT8</span><span class="p">]:</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">INT8</span><span class="p">:</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int8</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">INT16</span><span class="p">:</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">UINT16</span><span class="p">:</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">INT32</span><span class="p">:</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">UINT32</span><span class="p">:</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">FLOAT32</span><span class="p">:</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">FLOAT64</span><span class="p">:</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float64</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;read: illegal or unupported type </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> \
                                 <span class="n">data_type</span><span class="p">)</span>

            <span class="c1"># Unpack the field values.</span>
            <span class="n">_C</span><span class="o">.</span><span class="n">array_voidp_setitem</span><span class="p">(</span><span class="n">fldArr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;read&#39;</span><span class="p">,</span>
                      <span class="n">_C</span><span class="o">.</span><span class="n">VSfpack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fieldList</span><span class="p">,</span> <span class="n">bigBuf</span><span class="p">,</span> <span class="n">bufSize</span><span class="p">,</span>
                                 <span class="n">nRead</span><span class="p">,</span> <span class="n">fld</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">fldArr</span><span class="p">),</span>
                      <span class="s2">&quot;cannot execute&quot;</span><span class="p">)</span>

            <span class="c1"># Extract values from the field buffer.</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">numRec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nRead</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">values</span><span class="p">[</span><span class="n">numRec</span><span class="p">][</span><span class="n">numFld</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Handle strings specially</span>
                    <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">CHAR8</span><span class="p">:</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
                            <span class="n">v</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">s</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">values</span><span class="p">[</span><span class="n">numRec</span><span class="p">][</span><span class="n">numFld</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
                    <span class="c1"># Return field values as a list</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">values</span><span class="p">[</span><span class="n">numRec</span><span class="p">][</span><span class="n">numFld</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
                            <span class="n">values</span><span class="p">[</span><span class="n">numRec</span><span class="p">][</span><span class="n">numFld</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">del</span> <span class="n">buf</span>

        <span class="k">return</span> <span class="n">values</span></div>


<div class="viewcode-block" id="VD.write"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VD.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write records to the vdata. Writing starts at the current</span>
<span class="sd">        record position, which is advanced by the number of records</span>
<span class="sd">        written.</span>

<span class="sd">        Args::</span>

<span class="sd">          values: 2-level sequence. First level is a sequence of records.</span>
<span class="sd">                  A second level gives the sequence of record values.</span>
<span class="sd">                  It is mandatory to always write whole records. Thus</span>
<span class="sd">                  every record field must appear at the second level.</span>
<span class="sd">                  The record values are ordered according the list of</span>
<span class="sd">                  field names set in the last call to the setfields()</span>
<span class="sd">                  method. The ordre of the complete vdata field set is</span>
<span class="sd">                  used if setfields() has not been called.</span>


<span class="sd">        Returns::</span>

<span class="sd">          number of records written</span>

<span class="sd">        To append to a vdata already holding &#39;n&#39; records, it is necessary</span>
<span class="sd">        to first move the current record position to &#39;n-1&#39; with a call to</span>
<span class="sd">        method seek(), then to call method read() for the side effect</span>
<span class="sd">        of advancing the current record position past this last record.</span>
<span class="sd">        Method seekend() does just that.</span>

<span class="sd">        C library equivalent : VSwrite</span>
<span class="sd">                                                       &quot;&quot;&quot;</span>

        <span class="n">nFields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nfields</span>
        <span class="c1"># Fields give the order the record values, as defined in the</span>
        <span class="c1"># last call to setfields()</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setfields</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span>
        <span class="c1"># We must pack values using the effective field order in the vdata</span>
        <span class="n">fieldList</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">)</span>

        <span class="c1"># Validate the values argument.</span>
        <span class="k">if</span> <span class="n">nFields</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;write: must write whole records&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;write: values must be a sequence&quot;</span><span class="p">)</span>
        <span class="n">nRec</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nRec</span><span class="p">):</span>
            <span class="n">rec</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;write: records must be given as sequences&quot;</span><span class="p">)</span>
            <span class="c1"># Make sure each record is complete.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nFields</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;write: records must specify every field&quot;</span><span class="p">)</span>

        <span class="c1"># Allocate a buffer to store the packed records.</span>
        <span class="n">bufSize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recsize</span> <span class="o">*</span> <span class="n">nRec</span>
        <span class="n">bigBuf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">bufSize</span><span class="p">)</span>

        <span class="c1"># Allocate an array to store a pointer to the field buffer.</span>
        <span class="n">fldArr</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">new_array_voidp</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Pack each field in turn.</span>
        <span class="k">for</span> <span class="n">numFld</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nFields</span><span class="p">):</span>
            <span class="n">fld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="n">numFld</span><span class="p">])</span>
            <span class="n">data_type</span> <span class="o">=</span> <span class="n">fld</span><span class="o">.</span><span class="n">_type</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">fld</span><span class="o">.</span><span class="n">_order</span>
            <span class="n">n_values</span> <span class="o">=</span> <span class="n">order</span> <span class="o">*</span> <span class="n">nRec</span>

            <span class="c1"># Allocate a buffer to store the field values.</span>
            <span class="k">if</span> <span class="n">data_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">HC</span><span class="o">.</span><span class="n">CHAR8</span><span class="p">,</span> <span class="n">HC</span><span class="o">.</span><span class="n">UCHAR8</span><span class="p">,</span> <span class="n">HC</span><span class="o">.</span><span class="n">UINT8</span><span class="p">]:</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">INT8</span><span class="p">:</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int8</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">INT16</span><span class="p">:</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">UINT16</span><span class="p">:</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">INT32</span><span class="p">:</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">UINT32</span><span class="p">:</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">FLOAT32</span><span class="p">:</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">FLOAT64</span><span class="p">:</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float64</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;write: illegal or unupported type </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> \
                                 <span class="n">data_type</span><span class="p">)</span>

            <span class="c1"># Load the field buffer with values.</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">numRec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nRec</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">numRec</span><span class="p">][</span><span class="n">numFld</span><span class="p">]</span>
                <span class="c1"># Single-valued field</span>
                <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">buf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                    <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># Multi-valued field</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Handle strings specially.</span>
                    <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">CHAR8</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;char fields must be set with strings&quot;</span><span class="p">)</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
                            <span class="n">buf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">ord</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">or</span> <span class="mi">0</span>
                            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># Should validate field elements ...</span>
                    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;multi-values fields must be given as sequences&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
                            <span class="n">buf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Store address of the field buffer in first position</span>
            <span class="c1"># of the field array. Pack the field values.</span>
            <span class="n">_C</span><span class="o">.</span><span class="n">array_voidp_setitem</span><span class="p">(</span><span class="n">fldArr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span> <span class="c1"># fldArr[0] = buf</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;write&#39;</span><span class="p">,</span>
                      <span class="n">_C</span><span class="o">.</span><span class="n">VSfpack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fieldList</span><span class="p">,</span> <span class="n">bigBuf</span><span class="p">,</span> <span class="n">bufSize</span><span class="p">,</span>
                                 <span class="n">nRec</span><span class="p">,</span> <span class="n">fld</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">fldArr</span><span class="p">),</span>
                      <span class="s2">&quot;cannot execute&quot;</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">buf</span>

        <span class="c1"># Write the packed records.</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSwrite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">bigBuf</span><span class="p">,</span> <span class="n">nRec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>   <span class="c1"># 0: FULL_INTERLACE</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;write&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s1">&#39;cannot execute&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+=</span> <span class="n">nRec</span>

        <span class="k">return</span> <span class="n">n</span></div>

<div class="viewcode-block" id="VD.inquire"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VD.inquire">[docs]</a>    <span class="k">def</span> <span class="nf">inquire</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve info about the vdata.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          5-element tuple with the following elements:</span>
<span class="sd">            -number of records in the vdata</span>
<span class="sd">            -interlace mode</span>
<span class="sd">            -list of vdata field names</span>
<span class="sd">            -size in bytes of the vdata record</span>
<span class="sd">            -name of the vdata</span>

<span class="sd">        C library equivalent : VSinquire</span>
<span class="sd">                                             &quot;&quot;&quot;</span>

        <span class="n">status</span><span class="p">,</span> <span class="n">nRecs</span><span class="p">,</span> <span class="n">interlace</span><span class="p">,</span> <span class="n">fldNames</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">vName</span> <span class="o">=</span> \
                <span class="n">_C</span><span class="o">.</span><span class="n">VSinquire</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;inquire&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s2">&quot;cannot query vdata info&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nRecs</span><span class="p">,</span> <span class="n">interlace</span><span class="p">,</span> <span class="n">fldNames</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span> <span class="n">vName</span></div>


<div class="viewcode-block" id="VD.fieldinfo"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VD.fieldinfo">[docs]</a>    <span class="k">def</span> <span class="nf">fieldinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve info about all vdata fields.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          list where each element describes a field of the vdata;</span>
<span class="sd">          each field is described by an 7-element tuple containing</span>
<span class="sd">          the following elements:</span>

<span class="sd">          - field name</span>
<span class="sd">          - field data type (one of HC.xxx constants)</span>
<span class="sd">          - field order</span>
<span class="sd">          - number of attributes attached to the field</span>
<span class="sd">          - field index number</span>
<span class="sd">          - field external size</span>
<span class="sd">          - field internal size</span>

<span class="sd">        C library equivalent : no equivalent</span>
<span class="sd">                                                      &quot;&quot;&quot;</span>

        <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nfields</span><span class="p">):</span>
            <span class="n">fld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">fld</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span>
                        <span class="n">fld</span><span class="o">.</span><span class="n">_type</span><span class="p">,</span>
                        <span class="n">fld</span><span class="o">.</span><span class="n">_order</span><span class="p">,</span>
                        <span class="n">fld</span><span class="o">.</span><span class="n">_nattrs</span><span class="p">,</span>
                        <span class="n">fld</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span>
                        <span class="n">fld</span><span class="o">.</span><span class="n">_esize</span><span class="p">,</span>
                        <span class="n">fld</span><span class="o">.</span><span class="n">_isize</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">lst</span></div>

<div class="viewcode-block" id="VD.sizeof"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VD.sizeof">[docs]</a>    <span class="k">def</span> <span class="nf">sizeof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve the size in bytes of the given fields.</span>

<span class="sd">        Args::</span>

<span class="sd">          fields   sequence of field names to query</span>

<span class="sd">        Returns::</span>

<span class="sd">          total size of the fields in bytes</span>

<span class="sd">        C library equivalent : VSsizeof</span>
<span class="sd">                                                   &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
            <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">str</span> <span class="o">=</span> <span class="n">fields</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSsizeof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;sizeof&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot;cannot retrieve field sizes&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span></div>

<div class="viewcode-block" id="VD.fexist"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VD.fexist">[docs]</a>    <span class="k">def</span> <span class="nf">fexist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if a vdata contains a given set of fields.</span>

<span class="sd">        Args::</span>

<span class="sd">          fields   sequence of field names whose presence in the</span>
<span class="sd">                   vdata must be checked</span>

<span class="sd">        Returns::</span>

<span class="sd">          true  (1) if the given fields are present</span>
<span class="sd">          false (0) otherwise</span>

<span class="sd">        C library equivalent : VSfexist</span>
<span class="sd">                                                         &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
            <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">str</span> <span class="o">=</span> <span class="n">fields</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSfexist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="VD.attr"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VD.attr">[docs]</a>    <span class="k">def</span> <span class="nf">attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a VDAttr instance representing a vdata attribute.</span>

<span class="sd">        Args::</span>

<span class="sd">          name_or_index   attribute name or index number; if a name is</span>
<span class="sd">                          given, the attribute may not exist; in that</span>
<span class="sd">                          case, it will be created when the VSAttr</span>
<span class="sd">                          instance set() method is called</span>

<span class="sd">        Returns::</span>

<span class="sd">          VSAttr instance for the attribute. Call the methods of this</span>
<span class="sd">          class to query, read or set the attribute.</span>

<span class="sd">        C library equivalent : no equivalent</span>

<span class="sd">                                &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">VDAttr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_index</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># -1: vdata attribute</span></div>

<div class="viewcode-block" id="VD.findattr"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VD.findattr">[docs]</a>    <span class="k">def</span> <span class="nf">findattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Search the vdata for a given attribute.</span>

<span class="sd">        Args::</span>

<span class="sd">          name    attribute name</span>

<span class="sd">        Returns::</span>

<span class="sd">          if found, VDAttr instance describing the attribute</span>
<span class="sd">          None otherwise</span>

<span class="sd">         C library equivalent : VSfindattr</span>
<span class="sd">                                                  &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">att</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">att</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="n">HDF4Error</span><span class="p">:</span>
            <span class="n">att</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">att</span></div>

<div class="viewcode-block" id="VD.attrinfo"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VD.attrinfo">[docs]</a>    <span class="k">def</span> <span class="nf">attrinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return info about all the vdata attributes.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          dictionary describing each vdata attribute; for each attribute</span>
<span class="sd">          a (name,data) pair is added to the dictionary, where &#39;data&#39; is</span>
<span class="sd">          a tuple holding:</span>
<span class="sd">          - attribute data type (one of HC.xxx constants)</span>
<span class="sd">          - attribute order</span>
<span class="sd">          - attribute value</span>
<span class="sd">          - attribute size in bytes</span>

<span class="sd">        C library equivalent : no equivalent</span>
<span class="sd">                                                  &quot;&quot;&quot;</span>

        <span class="n">dic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nattrs</span><span class="p">):</span>
            <span class="n">att</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">att</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
            <span class="n">dic</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">att</span><span class="o">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">size</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dic</span></div>

    <span class="k">def</span> <span class="nf">__buildStartCount</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">setitem</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

        <span class="c1"># Called by __getitem__() and __setitem__() methods</span>
        <span class="c1"># to parse the expression used inside square brackets to</span>
        <span class="c1"># index/slice a vdata.</span>
        <span class="c1"># If &#39;setitem&#39; is set, the call comes from __setitem__()</span>
        <span class="c1"># We then allow the start value to be past the last record</span>
        <span class="c1"># so as to be able to append to the vdata.</span>
        <span class="c1">#</span>
        <span class="c1"># Return a 2-element tuple:</span>
        <span class="c1">#  - tuple of the start indices along the vdata dimensions</span>
        <span class="c1">#  - tuple of the count values along the vdata dimensions</span>
        <span class="c1">#    a count of -1 indicates that an index, not a slice</span>
        <span class="c1">#    was applied on the correcponding dimension.</span>

        <span class="c1"># Make sure the indexing expression does not exceed the</span>
        <span class="c1"># vdata number of dimensions (2).</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;illegal indexing expression&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>    <span class="c1"># Convert single index to sequence</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem</span><span class="p">]</span>

        <span class="n">start</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nrecs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nfields</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Simple index</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">is_slice</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">e</span> <span class="o">+=</span> <span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">e</span> <span class="o">&gt;=</span> <span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="ow">and</span> <span class="n">setitem</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;index out of range&quot;</span><span class="p">)</span>
                <span class="n">beg</span> <span class="o">=</span> <span class="n">e</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">e</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># Slice index</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">is_slice</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># None or 0 means not specified</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                    <span class="n">beg</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">start</span>
                    <span class="k">if</span> <span class="n">beg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">beg</span> <span class="o">+=</span> <span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">beg</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># None or maxint means not specified</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">stop</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">stop</span> <span class="o">!=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">:</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">stop</span>
                    <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">end</span> <span class="o">+=</span> <span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="c1"># Bug</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid indexing expression&quot;</span><span class="p">)</span>

            <span class="c1"># Clip end index and compute number of elements to get</span>
            <span class="k">if</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">beg</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
                <span class="n">beg</span> <span class="o">=</span> <span class="n">end</span>
            <span class="k">if</span> <span class="n">is_slice</span><span class="p">:</span>
                <span class="n">cnt</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">beg</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cnt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">start</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beg</span><span class="p">)</span>
            <span class="n">count</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">count</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">count</span></div>

<div class="viewcode-block" id="VDField"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VDField">[docs]</a><span class="k">class</span> <span class="nc">VDField</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The VDField class represents a vdata field.</span>
<span class="sd">    To create a VDField instance, call the field() method of a</span>
<span class="sd">    VD class instance. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vdinst</span><span class="p">,</span> <span class="n">fIndex</span><span class="p">):</span>
        <span class="c1"># This method should not be called directly by the user program.</span>
        <span class="c1"># To create a VDField instance, obtain a VD class instance and</span>
        <span class="c1"># call its field() method.</span>

        <span class="c1"># Args:</span>
        <span class="c1">#  vdinst    VD instance to which the field belongs</span>
        <span class="c1">#  fIndex    field index</span>
        <span class="c1">#</span>
        <span class="c1"># Private attributes:</span>
        <span class="c1">#  _vd_inst  VD instance to which the field belongs</span>
        <span class="c1">#  _idx      field index</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_vd_inst</span> <span class="o">=</span> <span class="n">vdinst</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span> <span class="o">=</span> <span class="n">fIndex</span>


    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Some field properties can be queried through the following</span>
<span class="sd">        read-only attributes. Their names all start with an &quot;_&quot; to avoid</span>
<span class="sd">        clashes with user-defined attributes.</span>

<span class="sd">        Name      Description              C library routine</span>
<span class="sd">        -----     -------------------      -----------------</span>
<span class="sd">        _esize     field external size      VFfieldesize</span>
<span class="sd">        _index     field index number       VSfindex</span>
<span class="sd">        _isize     field internal size      VFfieldisize</span>
<span class="sd">        _name      field name               VFfieldname</span>
<span class="sd">        _nattrs    number of attributes     VSfnattrs</span>
<span class="sd">        _order     field order              VFfieldorder</span>
<span class="sd">        _type      field type               VFfieldtype</span>

<span class="sd">                                                                   &quot;&quot;&quot;</span>
        <span class="c1"># Check for a user defined attribute first.</span>
        <span class="n">att</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>   <span class="c1"># Then the attribute exists</span>
            <span class="k">return</span> <span class="n">att</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

        <span class="c1"># Check for a predefined attribute.</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_esize&quot;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VFfieldesize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vd_inst</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="p">)</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;_esize&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot;execution error&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span>

        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_index&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span>

        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_isize&quot;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VFfieldisize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vd_inst</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="p">)</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;_isize&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot;execution error&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span>

        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_name&quot;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VFfieldname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vd_inst</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="p">)</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;_name&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot;execution error&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span>

        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_nattrs&quot;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSfnattrs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vd_inst</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="p">)</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;_nattrs&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot;execution error&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span>

        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_order&quot;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VFfieldorder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vd_inst</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="p">)</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;_order&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot;execution error&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span>

        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;_type&quot;</span><span class="p">:</span>
            <span class="nb">type</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VFfieldtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vd_inst</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="p">)</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;_type&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="s1">&#39;cannot retrieve field type&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">type</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span>


    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>

        <span class="c1"># Forbid assigning to our predefined attributes</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;_esize&quot;</span><span class="p">,</span> <span class="s2">&quot;_index&quot;</span><span class="p">,</span> <span class="s2">&quot;_isize&quot;</span><span class="p">,</span> <span class="s2">&quot;_name&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;_nattrs&quot;</span><span class="p">,</span> <span class="s2">&quot;_order&quot;</span><span class="p">,</span> <span class="s2">&quot;_type&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: read-only attribute&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

        <span class="c1"># Try to set the attribute.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="VDField.attr"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VDField.attr">[docs]</a>    <span class="k">def</span> <span class="nf">attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a VDAttr instance representing a field attribute.</span>

<span class="sd">        Args::</span>

<span class="sd">          name_or_index   attribute name or index number; if a name is</span>
<span class="sd">                          specified, the attribute may not exist; in that</span>
<span class="sd">                          case, it will be created when the VDAttr</span>
<span class="sd">                          instance set() method is called; if an</span>
<span class="sd">                          index number is specified, the attribute</span>
<span class="sd">                          must exist</span>

<span class="sd">        Returns::</span>

<span class="sd">          VSAttr instance for the attribute. Call the methods of this</span>
<span class="sd">          class to query, read or set the attribute.</span>

<span class="sd">        C library equivalent : no equivalent</span>

<span class="sd">                                &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">VDAttr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="p">)</span></div>

<div class="viewcode-block" id="VDField.find"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VDField.find">[docs]</a>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Search the field for a given attribute.</span>

<span class="sd">        Args::</span>

<span class="sd">          name    attribute name</span>

<span class="sd">        Returns::</span>

<span class="sd">          if found, VDAttr instance describing the attribute</span>
<span class="sd">          None otherwise</span>

<span class="sd">         C library equivalent : VSfindattr</span>
<span class="sd">                                                  &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">att</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">att</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="n">HDF4Error</span><span class="p">:</span>
            <span class="n">att</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">att</span></div>

<div class="viewcode-block" id="VDField.attrinfo"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VDField.attrinfo">[docs]</a>    <span class="k">def</span> <span class="nf">attrinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return info about all the field attributes.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          dictionary describing each vdata attribute; for each attribute</span>
<span class="sd">          a (name,data) pair is added to the dictionary, where &#39;data&#39; is</span>
<span class="sd">          a tuple holding:</span>

<span class="sd">          - attribute data type (one of HC.xxx constants)</span>
<span class="sd">          - attribute order</span>
<span class="sd">          - attribute value</span>
<span class="sd">          - attribute size in bytes</span>

<span class="sd">        C library equivalent : no equivalent</span>
<span class="sd">                                                  &quot;&quot;&quot;</span>

        <span class="n">dic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nattrs</span><span class="p">):</span>
            <span class="n">att</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">att</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
            <span class="n">dic</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">att</span><span class="o">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">size</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dic</span></div></div>


<div class="viewcode-block" id="VDAttr"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VDAttr">[docs]</a><span class="k">class</span> <span class="nc">VDAttr</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The VDAttr class encapsulates methods used to set and query attributes</span>
<span class="sd">    defined at the level either of the vdata or of the vdata field.</span>
<span class="sd">    To create an instance of this class, call the attr() method of a VD</span>
<span class="sd">    (vdata) or VDField (vdata field) instance. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">name_or_index</span><span class="p">,</span> <span class="n">fIndex</span><span class="p">):</span>
        <span class="c1"># This constructor should not be called directly by the user</span>
        <span class="c1"># program. The attr() method of a VD (vdata) or VDField</span>
        <span class="c1"># (vdata field) must be called to instantiate this class.</span>

        <span class="c1"># Args:</span>
        <span class="c1">#  obj            object instance (VD or VDField) to which the</span>
        <span class="c1">#                 attribute belongs</span>
        <span class="c1">#  name_or_index  name or index of the attribute; if a name is</span>
        <span class="c1">#                 given, an attribute with that name will be</span>
        <span class="c1">#                 searched, if not found, a new index number will</span>
        <span class="c1">#                 be generated</span>
        <span class="c1">#  fIndex         field index, or -1 if the attribute belongs</span>
        <span class="c1">#                 to the vdata</span>

        <span class="c1"># Private attributes:</span>
        <span class="c1">#  _vd_inst       VD instance</span>
        <span class="c1">#  _vdf_inst      VDField instance or None</span>
        <span class="c1">#  _index         attribute index or None</span>
        <span class="c1">#  _name          attribute name or None</span>
        <span class="c1">#  _fIndex        field index, or -1 obj is a VD instance</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">VD</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vd_inst</span> <span class="o">=</span> <span class="n">obj</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vdf_instance</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fIndex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vd_inst</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_vd_inst</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vdf_inst</span> <span class="o">=</span> <span class="n">obj</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fIndex</span> <span class="o">=</span> <span class="n">fIndex</span>
        <span class="c1"># Name is given. Attribute may exist or not.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_index</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name_or_index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSfindattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vd_inst</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fIndex</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">);</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Index is given. Attribute Must exist.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">name_or_index</span>
            <span class="n">status</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">n_values</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> \
                    <span class="n">_C</span><span class="o">.</span><span class="n">VSattrinfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vd_inst</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fIndex</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;attr&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;non-existent attribute&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="VDAttr.get"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VDAttr.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve the attribute value.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          attribute value(s); a list is returned if the attribute</span>
<span class="sd">          is made up of more than one value, except in the case of a</span>
<span class="sd">          string-valued attribute (data type HC.CHAR8) where the</span>
<span class="sd">          values are returned as a string</span>

<span class="sd">        C library equivalent : VSgetattr</span>

<span class="sd">                                                &quot;&quot;&quot;</span>
        <span class="c1"># Make sure th attribute exists.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;non existent attribute&quot;</span><span class="p">)</span>
        <span class="c1"># Obtain attribute type and the number of values.</span>
        <span class="n">status</span><span class="p">,</span> <span class="n">aName</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">n_values</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> \
                    <span class="n">_C</span><span class="o">.</span><span class="n">VSattrinfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vd_inst</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fIndex</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;get&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;illegal parameters&#39;</span><span class="p">)</span>

        <span class="c1"># Get attribute value.</span>
        <span class="n">convert</span> <span class="o">=</span> <span class="n">_array_to_ret</span>
        <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">CHAR8</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">convert</span> <span class="o">=</span> <span class="n">_array_to_str</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">HC</span><span class="o">.</span><span class="n">UCHAR8</span><span class="p">,</span> <span class="n">HC</span><span class="o">.</span><span class="n">UINT8</span><span class="p">]:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">INT8</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int8</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">INT16</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">UINT16</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">INT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">UINT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">FLOAT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">FLOAT64</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float64</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;get: attribute index </span><span class="si">%d</span><span class="s2"> has an &quot;</span>\
                             <span class="s2">&quot;illegal or unupported type </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> \
                             <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="n">data_type</span><span class="p">))</span>

        <span class="n">status</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSgetattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vd_inst</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fIndex</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;get&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;illegal attribute &#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">convert</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">n_values</span><span class="p">)</span></div>

<div class="viewcode-block" id="VDAttr.set"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VDAttr.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the attribute value.</span>

<span class="sd">        Args::</span>

<span class="sd">          data_type    : attribute data type (see constants HC.xxx)</span>
<span class="sd">          values       : attribute value(s); specify a list to create</span>
<span class="sd">                         a multi-valued attribute; a string valued</span>
<span class="sd">                         attribute can be created by setting &#39;data_type&#39;</span>
<span class="sd">                         to HC.CHAR8 and &#39;values&#39; to the corresponding</span>
<span class="sd">                         string</span>

<span class="sd">                         If the attribute already exists, it will be</span>
<span class="sd">                         updated. However, it is illegal to try to change</span>
<span class="sd">                         its data type or its order (number of values).</span>

<span class="sd">        Returns::</span>

<span class="sd">          None</span>

<span class="sd">        C library equivalent : VSsetattr</span>

<span class="sd">                                                  &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">n_values</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="p">]</span>
            <span class="n">n_values</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">CHAR8</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="c1"># Allow values to be passed as a string.</span>
            <span class="c1"># Noop if a list is passed.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_values</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">HC</span><span class="o">.</span><span class="n">UCHAR8</span><span class="p">,</span> <span class="n">HC</span><span class="o">.</span><span class="n">UINT8</span><span class="p">]:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">INT8</span><span class="p">:</span>
            <span class="c1"># SWIG refuses negative values here. We found that if we</span>
            <span class="c1"># pass them as byte values, it will work.</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int8</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_values</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">&amp;=</span> <span class="mh">0x7f</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span>
                    <span class="k">if</span> <span class="n">v</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="mi">256</span> <span class="o">-</span> <span class="n">v</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="mi">128</span>         <span class="c1"># -128 in 2s complement</span>
                <span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">INT16</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">UINT16</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">INT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">UINT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">FLOAT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HC</span><span class="o">.</span><span class="n">FLOAT64</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float64</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;set: illegal or unimplemented data_type&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_values</span><span class="p">):</span>
            <span class="n">buf</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSsetattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vd_inst</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fIndex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span>
                              <span class="n">data_type</span><span class="p">,</span> <span class="n">n_values</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;attr&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;cannot execute&#39;</span><span class="p">)</span>
        <span class="c1"># Update the attribute index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">VSfindattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vd_inst</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fIndex</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">);</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;set: error retrieving attribute index&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VDAttr.info"><a class="viewcode-back" href="../../modules/VS.html#pyhdf.VS.VDAttr.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve info about the attribute.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          4-element tuple with the following components:</span>
<span class="sd">            -attribute name</span>
<span class="sd">            -attribute data type (one of HC.xxx constants)</span>
<span class="sd">            -attribute order (number of values)</span>
<span class="sd">            -attribute size in bytes</span>

<span class="sd">        C library equivalent : VSattrinfo</span>
<span class="sd">                                                           &quot;&quot;&quot;</span>

        <span class="c1"># Make sure the attribute exists.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;non existent attribute&quot;</span><span class="p">)</span>

        <span class="n">status</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> \
                <span class="n">_C</span><span class="o">.</span><span class="n">VSattrinfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vd_inst</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fIndex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s2">&quot;execution error&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">size</span></div></div>


<span class="c1">###########################</span>
<span class="c1"># Support functions</span>
<span class="c1">###########################</span>


<span class="k">def</span> <span class="nf">_setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="c1"># Called by the __setattr__ method of the VD and VDField objects.</span>
    <span class="c1">#</span>
    <span class="c1">#  obj   instance on which the attribute is set</span>
    <span class="c1">#  name  attribute name</span>
    <span class="c1">#  value attribute value</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf8&#39;</span><span class="p">)</span>

    <span class="c1"># Treat a name starting with and underscore as that of a</span>
    <span class="c1"># standard python instance attribute.</span>
    <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;_&#39;</span><span class="p">:</span>
        <span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span>

    <span class="c1"># Treat everything else as an HDF attribute.</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
    <span class="n">typeList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="c1"># Prohibit mixing numeric types and strings.</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="ow">and</span> \
               <span class="ow">not</span> <span class="nb">bytes</span> <span class="ow">in</span> <span class="n">typeList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">typeList</span><span class="p">:</span>
                <span class="n">typeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="c1"># Prohibit sequence of strings or a mix of numbers and string.</span>
        <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="nb">bytes</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">typeList</span><span class="p">:</span>
            <span class="n">typeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">typeList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">break</span>
    <span class="k">if</span> <span class="nb">bytes</span> <span class="ow">in</span> <span class="n">typeList</span><span class="p">:</span>
        <span class="n">xtype</span> <span class="o">=</span> <span class="n">HC</span><span class="o">.</span><span class="n">CHAR8</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># double is &quot;stronger&quot; than int</span>
    <span class="k">elif</span> <span class="nb">float</span> <span class="ow">in</span> <span class="n">typeList</span><span class="p">:</span>
        <span class="n">xtype</span> <span class="o">=</span> <span class="n">HC</span><span class="o">.</span><span class="n">FLOAT64</span>
    <span class="k">elif</span> <span class="nb">int</span> <span class="ow">in</span> <span class="n">typeList</span><span class="p">:</span>
        <span class="n">xtype</span> <span class="o">=</span> <span class="n">HC</span><span class="o">.</span><span class="n">INT32</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;Illegal attribute value&quot;</span><span class="p">)</span>

    <span class="c1"># Assign value</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xtype</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">HDF4Error</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;cannot set attribute: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">msg</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_array_to_ret</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">nValues</span><span class="p">):</span>

    <span class="c1"># Convert array &#39;buf&#39; to a scalar or a list.</span>

    <span class="k">if</span> <span class="n">nValues</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nValues</span><span class="p">):</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">ret</span>

<span class="k">def</span> <span class="nf">_array_to_str</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">nValues</span><span class="p">):</span>

    <span class="c1"># Convert array of bytes &#39;buf&#39; to a string.</span>

    <span class="c1"># Return empty string if there is no value.</span>
    <span class="k">if</span> <span class="n">nValues</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span>
    <span class="c1"># When there is just one value, _array_to_ret returns a scalar</span>
    <span class="c1"># over which we cannot iterate.</span>
    <span class="k">if</span> <span class="n">nValues</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">chrs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">chrs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">_array_to_ret</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">nValues</span><span class="p">)]</span>
    <span class="c1"># Strip NULL at end</span>
    <span class="k">if</span> <span class="n">chrs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">chrs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chrs</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pyhdf 0.10.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, pyhdf authors.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.1.
    </div>
  </body>
</html>