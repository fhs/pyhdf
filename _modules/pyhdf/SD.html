
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pyhdf.SD &#8212; pyhdf 0.10.0 documentation</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pyhdf 0.10.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pyhdf.SD</h1><div class="highlight"><pre>
<span></span><span class="c1"># $Id: SD.py,v 1.10 2008-08-05 00:20:44 gosselin_a Exp $</span>
<span class="c1"># $Log: not supported by cvs2svn $</span>
<span class="c1"># Revision 1.9  2008/06/30 02:59:57  gosselin_a</span>
<span class="c1"># Fixed definition of equivNumericTypes list.</span>
<span class="c1">#</span>
<span class="c1"># Revision 1.8  2008/06/30 02:41:44  gosselin_a</span>
<span class="c1"># Preleminary check-in of changes leading to the 0.8 revision.</span>
<span class="c1">#   - switch to numpy, Numeric now unsupported</span>
<span class="c1">#   - better documentation of the compression features</span>
<span class="c1">#   - some bug fixes</span>
<span class="c1">#</span>
<span class="c1"># Revision 1.7  2005/07/14 01:36:41  gosselin_a</span>
<span class="c1"># pyhdf-0.7-3</span>
<span class="c1"># Ported to HDF4.2r1.</span>
<span class="c1"># Support for SZIP compression on SDS datasets.</span>
<span class="c1"># All classes are now &#39;new-style&#39; classes, deriving from &#39;object&#39;.</span>
<span class="c1"># Update documentation.</span>
<span class="c1">#</span>
<span class="c1"># Revision 1.6  2005/01/25 18:17:53  gosselin_a</span>
<span class="c1"># Importer le symbole &#39;HDF4Error&#39; a partir du module SD.</span>
<span class="c1">#</span>
<span class="c1"># Revision 1.5  2004/08/02 17:06:20  gosselin</span>
<span class="c1"># pyhdf-0.7.2</span>
<span class="c1">#</span>
<span class="c1"># Revision 1.4  2004/08/02 15:36:04  gosselin</span>
<span class="c1"># pyhdf-0.7-1</span>
<span class="c1">#</span>
<span class="c1"># Revision 1.3  2004/08/02 15:22:59  gosselin</span>
<span class="c1"># pyhdf -0.6-1</span>
<span class="c1">#</span>
<span class="c1"># Revision 1.2  2004/08/02 15:00:34  gosselin</span>
<span class="c1"># pyhdf 0.5-2</span>
<span class="c1">#</span>
<span class="c1"># Author: Andre Gosselin</span>
<span class="c1">#         Maurice Lamontagne Institute</span>
<span class="c1">#         Andre.Gosselin@dfo-mpo.gc.ca</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">SD (scientific dataset) API (:mod:`pyhdf.SD`)</span>
<span class="sd">=============================================</span>

<span class="sd">A module of the pyhdf package implementing the SD (scientific</span>
<span class="sd">dataset) API of the NCSA HDF4 library.</span>
<span class="sd">(see: hdf.ncsa.uiuc.edu)</span>

<span class="sd">Introduction</span>
<span class="sd">------------</span>
<span class="sd">SD is one of the modules composing pyhdf, a python package implementing</span>
<span class="sd">the NCSA HDF library and letting one manage HDF files from within a python</span>
<span class="sd">program. Two versions of the HDF library currently exist, version 4 and</span>
<span class="sd">version 5. pyhdf only implements version 4 of the library. Many</span>
<span class="sd">different APIs are to be found inside the HDF4 specification.</span>
<span class="sd">Currently, pyhdf implements just a few of those: the SD, VS and V APIs.</span>
<span class="sd">Other APIs should be added in the future (GR, AN, etc).</span>

<span class="sd">The SD module implements the SD API of the HDF4 library, supporting what</span>
<span class="sd">are known as &quot;scientific datasets&quot;. The HDF SD API has many similarities</span>
<span class="sd">with the netCDF API, another popular API for dealing with scientific</span>
<span class="sd">datasets. netCDF files can be in fact read and modified using the SD</span>
<span class="sd">module (but cannot be created from scratch).</span>

<span class="sd">SD module key features</span>
<span class="sd">----------------------</span>
<span class="sd">SD key features are as follows.</span>

<span class="sd">- Almost every routine of the original SD API has been implemented inside</span>
<span class="sd">  pyhdf. Only a few have been ignored, most of them being of a rare use:</span>

<span class="sd">  - SDsetnbitdataset()</span>
<span class="sd">  - All chunking/tiling routines : SDgetchunkinfo(), SDreadchunk(),</span>
<span class="sd">    SDsetchunk(), SDsetchunkcache(), SDwritechunk()</span>
<span class="sd">  - SDsetblocksize()</span>
<span class="sd">  - SDisdimval_bwcomp(), SDsetdimval_comp()</span>

<span class="sd">- It is quite straightforward to go from a C version to a python version</span>
<span class="sd">  of a program accessing the SD API, and to learn SD usage by refering to</span>
<span class="sd">  the C API documentation.</span>

<span class="sd">- A few high-level python methods have been developped to ease</span>
<span class="sd">  programmers task. Of greatest interest are those allowing access</span>
<span class="sd">  to SD datasets through familiar python idioms.</span>

<span class="sd">  - Attributes can be read/written like ordinary python class</span>
<span class="sd">    attributes.</span>
<span class="sd">  - Datasets can be read/written like ordinary python lists using</span>
<span class="sd">    multidimensional indices and so-called &quot;extended slice syntax&quot;, with</span>
<span class="sd">    strides allowed.</span>

<span class="sd">    See &quot;High level attribute access&quot; and &quot;High level variable access&quot;</span>
<span class="sd">    sections for details.</span>

<span class="sd">  - SD offers methods to retrieve a dictionnary of the attributes,</span>
<span class="sd">    dimensions and variables defined on a dataset, and of the attributes</span>
<span class="sd">    set on a variable and a dimension. Querying a dataset is thus geatly</span>
<span class="sd">    simplified.</span>

<span class="sd">- SD datasets are read/written through &quot;numpy&quot;, a sophisticated</span>
<span class="sd">  python package for efficiently handling multi-dimensional arrays of</span>
<span class="sd">  numbers. numpy can nicely extend the SD functionnality, eg.</span>
<span class="sd">  adding/subtracting arrays with the &#39;+/-&#39; operators.</span>

<span class="sd">Accessing the SD module</span>
<span class="sd">-----------------------</span>
<span class="sd">To access the SD API a python program can say one of:</span>

<span class="sd">  &gt;&gt;&gt; import pyhdf.SD        # must prefix names with &quot;pyhdf.SD.&quot;</span>
<span class="sd">  &gt;&gt;&gt; from pyhdf import SD   # must prefix names with &quot;SD.&quot;</span>
<span class="sd">  &gt;&gt;&gt; from pyhdf.SD import * # names need no prefix</span>

<span class="sd">This document assumes the last import style is used.</span>

<span class="sd">numpy will also need to be imported:</span>

<span class="sd">  &gt;&gt;&gt; from numpy import *</span>

<span class="sd">Package components</span>
<span class="sd">------------------</span>
<span class="sd">pyhdf is a proper Python package, eg a collection of modules stored under</span>
<span class="sd">a directory whose name is that of the package and which stores an</span>
<span class="sd">__init__.py file. Following the normal installation procedure, this</span>
<span class="sd">directory will be &lt;python-lib&gt;/site-packages/pyhdf&#39;, where &lt;python-lib&gt;</span>
<span class="sd">stands for the python installation directory.</span>

<span class="sd">For each HDF API exists a corresponding set of modules.</span>

<span class="sd">The following modules are related to the SD API.</span>

<span class="sd">  _hdfext</span>
<span class="sd">    C extension module responsible for wrapping the HDF</span>
<span class="sd">    C-library for all python modules</span>
<span class="sd">  hdfext</span>
<span class="sd">    python module implementing some utility functions</span>
<span class="sd">    complementing the _hdfext extension module</span>
<span class="sd">  error</span>
<span class="sd">    defines the HDF4Error exception</span>
<span class="sd">  SD</span>
<span class="sd">    python module wrapping the SD API routines inside</span>
<span class="sd">    an OOP framework</span>

<span class="sd">_hdfext and hdfext were generated using the SWIG preprocessor.</span>
<span class="sd">SWIG is however *not* needed to run the package. Those two modules</span>
<span class="sd">are meant to do their work in the background, and should never be called</span>
<span class="sd">directly. Only &#39;pyhdf.SD&#39; should be imported by the user program.</span>

<span class="sd">Prerequisites</span>
<span class="sd">-------------</span>
<span class="sd">The following software must be installed in order for pyhdf release 0.8 to</span>
<span class="sd">work.</span>

<span class="sd">  HDF (v4) library, release 4.2r1</span>
<span class="sd">    pyhdf does *not* include the HDF4 library, which must</span>
<span class="sd">    be installed separately.</span>

<span class="sd">    HDF is available at:</span>
<span class="sd">    &quot;http://hdf.ncsa.uiuc.edu/obtain.html&quot;.</span>

<span class="sd">  HDF4.2r1 in turn relies on the following packages :</span>

<span class="sd">    ======= ============== ===========================================</span>
<span class="sd">    libjpeg (jpeg library) release 6b</span>
<span class="sd">    libz    (zlib library) release 1.1.4 or above</span>
<span class="sd">    libsz   (SZIP library) release 2.0; this package is optional</span>
<span class="sd">                           if pyhdf is installed with NOSZIP macro set</span>
<span class="sd">    ======= ============== ===========================================</span>

<span class="sd">The SD module also needs:</span>

<span class="sd">  numpy python package</span>
<span class="sd">    SD variables are read/written using the array data type provided</span>
<span class="sd">    by the python NumPy package. Note that since version 0.8 of</span>
<span class="sd">    pyhdf, version 1.0.5 or above of NumPy is needed.</span>

<span class="sd">    numpy is available at:</span>
<span class="sd">    &quot;http://www.numpy.org&quot;.</span>

<span class="sd">Documentation</span>
<span class="sd">-------------</span>
<span class="sd">pyhdf has been written so as to stick as closely as possible to</span>
<span class="sd">the naming conventions and calling sequences documented inside the</span>
<span class="sd">&quot;HDF User s Guide&quot; manual. Even if pyhdf gives an OOP twist</span>
<span class="sd">to the C API, the manual can be easily used as a documentary source</span>
<span class="sd">for pyhdf, once the class to which a function belongs has been</span>
<span class="sd">identified, and of course once requirements imposed by the Python</span>
<span class="sd">langage have been taken into account. Consequently, this documentation</span>
<span class="sd">will not attempt to provide an exhaustive coverage of the HDF SD</span>
<span class="sd">API. For this, the user is referred to the above manual.</span>
<span class="sd">The documentation of each pyhdf method will indicate the name</span>
<span class="sd">of the equivalent routine inside the C API.</span>

<span class="sd">This document (in both its text and html versions) has been completely</span>
<span class="sd">produced using &quot;pydoc&quot;, the Python documentation generator (which</span>
<span class="sd">made its debut in the 2.1 Python release). pydoc can also be used</span>
<span class="sd">as an on-line help tool. For example, to know everything about</span>
<span class="sd">the SD.SDS class, say:</span>

<span class="sd">  &gt;&gt;&gt; from pydoc import help</span>
<span class="sd">  &gt;&gt;&gt; from pyhdf.SD import *</span>
<span class="sd">  &gt;&gt;&gt; help(SDS)</span>

<span class="sd">To be more specific and get help only for the get() method of the</span>
<span class="sd">SDS class:</span>

<span class="sd">  &gt;&gt;&gt; help(SDS.get)   # or...</span>
<span class="sd">  &gt;&gt;&gt; help(vinst.get) # if vinst is an SDS instance</span>

<span class="sd">pydoc can also be called from the command line, as in::</span>

<span class="sd">  % pydoc pyhdf.SD.SDS        # doc for the whole SDS class</span>
<span class="sd">  % pydoc pyhdf.SD.SDS.get    # doc for the SDS.get method</span>

<span class="sd">Summary of differences between the pyhdf and C SD API</span>
<span class="sd">-----------------------------------------------------</span>
<span class="sd">Most of the differences between the pyhdf and C SD API can</span>
<span class="sd">be summarized as follows.</span>

<span class="sd">- In the C API, every function returns an integer status code, and values</span>
<span class="sd">  computed by the function are returned through one or more pointers</span>
<span class="sd">  passed as arguments.</span>
<span class="sd">- In pyhdf, error statuses are returned through the Python exception</span>
<span class="sd">  mechanism, and values are returned as the method result. When the</span>
<span class="sd">  C API specifies that multiple values are returned, pyhdf returns a</span>
<span class="sd">  tuple of values, which are ordered similarly to the pointers in the</span>
<span class="sd">  C function argument list.</span>

<span class="sd">Error handling</span>
<span class="sd">--------------</span>
<span class="sd">All errors that the C SD API reports with a SUCCESS/FAIL error code</span>
<span class="sd">are reported by pyhdf using the Python exception mechanism.</span>
<span class="sd">When the C library reports a FAIL status, pyhdf raises an HDF4Error</span>
<span class="sd">exception (a subclass of Exception) with a descriptive message.</span>
<span class="sd">Unfortunately, the C library is rarely informative about the cause of</span>
<span class="sd">the error. pyhdf does its best to try to document the error, but most</span>
<span class="sd">of the time cannot do more than saying &quot;execution error&quot;.</span>

<span class="sd">Attribute access: low and high level</span>
<span class="sd">------------------------------------</span>
<span class="sd">In the SD API, attributes can be of many types (integer, float, string,</span>
<span class="sd">etc) and can be single or multi-valued. Attributes can be set either at</span>
<span class="sd">the dataset, the variable or the dimension level. This can can be achieved</span>
<span class="sd">in two ways.</span>

<span class="sd">- By calling the get()/set() method of an attribute instance. In the</span>
<span class="sd">  following example, HDF file &#39;example.hdf&#39; is created, and string</span>
<span class="sd">  attribute &#39;title&#39; is attached to the file and given value</span>
<span class="sd">  &#39;example&#39;.</span>

<span class="sd">     &gt;&gt;&gt; from pyhdf.SD import *</span>
<span class="sd">     &gt;&gt;&gt; d = SD(&#39;example.hdf&#39;,SDC.WRITE|SDC.CREATE)  # create file</span>
<span class="sd">     &gt;&gt;&gt; att = d.attr(&#39;title&#39;)            # create attribute instance</span>
<span class="sd">     &gt;&gt;&gt; att.set(SDC.CHAR, &#39;example&#39;)     # set attribute type and value</span>
<span class="sd">     &gt;&gt;&gt; print(att.get())                  # get attribute value</span>
<span class="sd">     &gt;&gt;&gt;</span>

<span class="sd">- By handling the attribute like an ordinary Python class attribute.</span>
<span class="sd">  The above example can then be rewritten as follows:</span>

<span class="sd">     &gt;&gt;&gt; from pyhdf.SD import *</span>
<span class="sd">     &gt;&gt;&gt; d = SD(&#39;example.hdf&#39;,SDC.WRITE|SDC.CREATE)  # create dataset</span>
<span class="sd">     &gt;&gt;&gt; d.title = &#39;example&#39;              # set attribute type and value</span>
<span class="sd">     &gt;&gt;&gt; print(d.title)                    # get attribute value</span>
<span class="sd">     &gt;&gt;&gt;</span>

<span class="sd">What has been said above applies as well to multi-valued attributes.</span>

<span class="sd">    &gt;&gt;&gt; att = d.attr(&#39;values&#39;)            # With an attribute instance</span>
<span class="sd">    &gt;&gt;&gt; att.set(SDC.INT32, (1,2,3,4,5))   # Assign 5 ints as attribute value</span>
<span class="sd">    &gt;&gt;&gt; att.get()                         # Get attribute values</span>
<span class="sd">    [1, 2, 3, 4, 5]</span>

<span class="sd">    &gt;&gt;&gt; d.values = (1,2,3,4,5)            # As a Python class attribute</span>
<span class="sd">    &gt;&gt;&gt; d.values                          # Get attribute values</span>
<span class="sd">    [1, 2, 3, 4, 5]</span>

<span class="sd">When the attribute is known by its name , standard functions &#39;setattr()&#39;</span>
<span class="sd">and &#39;getattr()&#39; can be used to replace the dot notation.</span>
<span class="sd">Above example becomes:</span>

<span class="sd">    &gt;&gt;&gt; setattr(d, &#39;values&#39;, (1,2,3,4,5))</span>
<span class="sd">    &gt;&gt;&gt; getattr(d, &#39;values&#39;)</span>
<span class="sd">    [1, 2, 3, 4, 5]</span>

<span class="sd">Handling a SD attribute like a Python class attribute is admittedly</span>
<span class="sd">more natural, and also much simpler. Some control is however lost in</span>
<span class="sd">doing so.</span>

<span class="sd">- Attribute type cannot be specified. pyhdf automatically selects one of</span>
<span class="sd">  three types according to the value(s) assigned to the attribute:</span>
<span class="sd">  SDC.CHAR if value is a string, SDC.INT32 if all values are integral,</span>
<span class="sd">  SDC.DOUBLE if one value is a float.</span>
<span class="sd">- Consequently, byte values cannot be assigned.</span>
<span class="sd">- Attribute properties (length, type, index number) can only be queried</span>
<span class="sd">  through methods of an attribute instance.</span>

<span class="sd">Variable access: low and high level</span>
<span class="sd">-----------------------------------</span>
<span class="sd">Similarly to attributes, datasets can be read/written in two ways.</span>

<span class="sd">The first way is through the get()/set() methods of a dataset instance.</span>
<span class="sd">Those methods accept parameters to specify the starting indices, the count</span>
<span class="sd">of values to read/write, and the strides along each dimension. For example,</span>
<span class="sd">if &#39;v&#39; is a 4x4 array:</span>

<span class="sd">    &gt;&gt;&gt; v.get()                         # complete array</span>
<span class="sd">    &gt;&gt;&gt; v.get(start=(0,0),count=(1,4))  # first row</span>
<span class="sd">    &gt;&gt;&gt; v.get(start=(0,1),count=(2,2),  # second and third columns of</span>
<span class="sd">    ...       stride=(2,1))             # first and third row</span>

<span class="sd">The second way is by indexing and slicing the variable like a Python</span>
<span class="sd">sequence. pyhdf here follows most of the rules used to index and slice</span>
<span class="sd">numpy arrays. Thus an HDF dataset can be seen almost as a numpy</span>
<span class="sd">array, except that data is read from/written to a file instead of memory.</span>

<span class="sd">Extended indexing let you access variable elements with the familiar</span>
<span class="sd">[i,j,...] notation, with one index per dimension. For example, if &#39;m&#39; is a</span>
<span class="sd">rank 3 dataset, one could write:</span>

<span class="sd">    &gt;&gt;&gt; m[0,3,5] = m[0,5,3]</span>

<span class="sd">When indexing is used to select a dimension in a &#39;get&#39; operation, this</span>
<span class="sd">dimension is removed from the output array, thus reducing its rank by 1. A</span>
<span class="sd">rank 0 array is converted to a scalar. Thus, for a 3x3x3 &#39;m&#39; dataset</span>
<span class="sd">(rank 3) of integer type :</span>

<span class="sd">    &gt;&gt;&gt; a = m[0]         # a is a 3x3 array (rank 2)</span>
<span class="sd">    &gt;&gt;&gt; a = m[0,0]       # a is a 3 element array (rank 1)</span>
<span class="sd">    &gt;&gt;&gt; a = m[0,0,0]     # a is an integer (rank 0 array becomes a scalar)</span>

<span class="sd">Had this rule not be followed, m[0,0,0] would have resulted in a single</span>
<span class="sd">element array, which could complicate computations.</span>

<span class="sd">Extended slice syntax allows slicing HDF datasets along each of its</span>
<span class="sd">dimensions, with the specification of optional strides to step through</span>
<span class="sd">dimensions at regular intervals. For each dimension, the slice syntax</span>
<span class="sd">is: &quot;i:j[:stride]&quot;, the stride being optional. As with ordinary slices,</span>
<span class="sd">the starting and ending values of a slice can be omitted to refer to the</span>
<span class="sd">first and last element, respectively, and the end value can be negative to</span>
<span class="sd">indicate that the index is measured relative to the tail instead of the</span>
<span class="sd">beginning. Omitted dimensions are assumed to be sliced from beginning to</span>
<span class="sd">end. Thus:</span>

<span class="sd">    &gt;&gt;&gt; m[0]             # treated as &#39;m[0,:,:]&#39;.</span>

<span class="sd">Example above with get()/set() methods can thus be rewritten as follows:</span>

<span class="sd">    &gt;&gt;&gt; v[:]             # complete array</span>
<span class="sd">    &gt;&gt;&gt; v[:1]            # first row</span>
<span class="sd">    &gt;&gt;&gt; v[::2,1:3]       # second and third columns of first and third row</span>

<span class="sd">Indexes and slices can be freely mixed, eg:</span>

<span class="sd">    &gt;&gt;&gt; m[:2,3,1:3:2]</span>

<span class="sd">Note that, countrary to indexing, a slice never reduces the rank of the</span>
<span class="sd">output array, even if its length is 1. For example, given a 3x3x3 &#39;m&#39;</span>
<span class="sd">dataset:</span>

<span class="sd">    &gt;&gt;&gt; a = m[0]         # indexing: a is a 3x3 array (rank 2)</span>
<span class="sd">    &gt;&gt;&gt; a = m[0:1]       # slicing: a is a 1x3x3 array (rank 3)</span>

<span class="sd">As can easily be seen, extended slice syntax is much more elegant and</span>
<span class="sd">compact, and offers a few possibilities not easy to achieve with the</span>
<span class="sd">get()/sett() methods. Negative indices offer a nice example:</span>

<span class="sd">    &gt;&gt;&gt; v[-2:]                         # last two rows</span>
<span class="sd">    &gt;&gt;&gt; v[-3:-1]                       # second and third row</span>
<span class="sd">    &gt;&gt;&gt; v[:,-1]                        # last column</span>

<span class="sd">Reading/setting multivalued HDF attributes and variables</span>
<span class="sd">--------------------------------------------------------</span>
<span class="sd">Multivalued HDF attributes are set using a python sequence (tuple or</span>
<span class="sd">list). Reading such an attribute returns a python list. The easiest way to</span>
<span class="sd">read/set an attribute is by handling it like a Python class attribute</span>
<span class="sd">(see &quot;High level attribute access&quot;). For example:</span>

<span class="sd">    &gt;&gt;&gt; d=SD(&#39;test.hdf&#39;,SDC.WRITE|SDC.CREATE)  # create file</span>
<span class="sd">    &gt;&gt;&gt; d.integers = (1,2,3,4)         # define multivalued integer attr</span>
<span class="sd">    &gt;&gt;&gt; d.integers                     # get the attribute value</span>
<span class="sd">    [1, 2, 3, 4]</span>

<span class="sd">The easiest way to set multivalued HDF datasets is to assign to a</span>
<span class="sd">subset of the dataset, using &quot;[:]&quot; to assign to the whole dataset</span>
<span class="sd">(see &quot;High level variable access&quot;). The assigned value can be a python</span>
<span class="sd">sequence, which can be multi-leveled when assigning to a multdimensional</span>
<span class="sd">dataset. For example:</span>

<span class="sd">    &gt;&gt;&gt; d=SD(&#39;test.hdf&#39;,SDC.WRITE|SDC.CREATE) # create file</span>
<span class="sd">    &gt;&gt;&gt; v1=d.create(&#39;v1&#39;,SDC.INT32,3)         # 3-elem vector</span>
<span class="sd">    &gt;&gt;&gt; v1[:]=[1,2,3]                         # assign 3-elem python list</span>
<span class="sd">    &gt;&gt;&gt; v2=d.create(&#39;d2&#39;,SDC.INT32,(3,3))     # create 3x3 variable</span>
<span class="sd">           # The list assigned to v2 is composed</span>
<span class="sd">           # of 3 lists, each representing a row of v2.</span>
<span class="sd">    &gt;&gt;&gt; v2[:]=[[1,2,3],[11,12,13],[21,22,23]]</span>

<span class="sd">The assigned value can also be a numpy array. Rewriting example above:</span>

<span class="sd">    &gt;&gt;&gt; v1=array([1,2,3])</span>
<span class="sd">    &gt;&gt;&gt; v2=array([[1,2,3],[11,12,13],[21,22,23]])</span>

<span class="sd">Note how we use indexing expressions &#39;v1[:]&#39; and &#39;v2[:]&#39; when assigning</span>
<span class="sd">using python sequences, and just the variable names when assigning numpy</span>
<span class="sd">arrays.</span>

<span class="sd">Reading an HDF dataset always returns a numpy array, except if</span>
<span class="sd">indexing is used and produces a rank-0 array, in which case a scalar is</span>
<span class="sd">returned.</span>

<span class="sd">netCDF files</span>
<span class="sd">------------</span>
<span class="sd">Files written in the popular Unidata netCDF format can be read and updated</span>
<span class="sd">using the HDF SD API. However, pyhdf cannot create netCDF formatted</span>
<span class="sd">files from scratch. The python &#39;pycdf&#39; package can be used for that.</span>

<span class="sd">When accessing netCDF files through pyhdf, one should be aware of the</span>
<span class="sd">following differences between the netCDF and the HDF SD libraries.</span>

<span class="sd">- Differences in terminology can be confusing. What netCDF calls a</span>
<span class="sd">  &#39;dataset&#39; is called a &#39;file&#39; or &#39;SD interface&#39; in HDF. What HDF calls</span>
<span class="sd">  a dataset is called a &#39;variable&#39; in netCDF parlance.</span>
<span class="sd">- In the netCDF API, dimensions are defined at the global (netCDF dataset)</span>
<span class="sd">  level. Thus, two netCDF variables defined over dimensions X and Y</span>
<span class="sd">  necessarily have the same rank and shape.</span>
<span class="sd">- In the HDF SD API, dimensions are defined at the HDF dataset level,</span>
<span class="sd">  except when they are named. Dimensions with the same name are considered</span>
<span class="sd">  to be &quot;shared&quot; between all the file datasets. They must be of the same</span>
<span class="sd">  length, and they share all their scales and attributes. For example,</span>
<span class="sd">  setting an attribute on a shared dimension affects all datasets sharing</span>
<span class="sd">  that dimension.</span>
<span class="sd">- When two or more netCDF variables are based on the unlimited dimension,</span>
<span class="sd">  they automatically grow in sync. If variables A and B use the unlimited</span>
<span class="sd">  dimension, adding &quot;records&quot; to A along its unlimited dimension</span>
<span class="sd">  implicitly adds records in B (which are left in an undefined state and</span>
<span class="sd">  filled with the fill_value when the file is refreshed).</span>
<span class="sd">- In HDF, unlimited dimensions behave independently. If HDF datasets A and</span>
<span class="sd">  B are based on an unlimited dimension, adding records to A does not</span>
<span class="sd">  affect the number of records to B. This is true even if the unlimited</span>
<span class="sd">  dimensions bear the same name (they do not appear to be &quot;shared&quot; as is</span>
<span class="sd">  the case when the dimensions are fixed).</span>


<span class="sd">Classes summary</span>
<span class="sd">---------------</span>
<span class="sd">pyhdf wraps the SD API using different types of python classes::</span>

<span class="sd">  SD     HDF SD interface (almost synonymous with the subset of the</span>
<span class="sd">         HDF file holding all the SD datasets)</span>
<span class="sd">  SDS    scientific dataset</span>
<span class="sd">  SDim   dataset dimension</span>
<span class="sd">  SDAttr attribute (either at the file, dataset or dimension level)</span>
<span class="sd">  SDC    constants (opening modes, data types, etc)</span>

<span class="sd">In more detail::</span>

<span class="sd">  SD     The SD class implements the HDF SD interface as applied to a given</span>
<span class="sd">         file. This class encapsulates the &quot;SD interface&quot; identifier</span>
<span class="sd">         (referred to as &quot;sd_id&quot; in the C API documentation), and all</span>
<span class="sd">         the SD API top-level functions.</span>

<span class="sd">         To create an SD instance, call the SD() constructor.</span>

<span class="sd">         methods:</span>
<span class="sd">           constructors:</span>
<span class="sd">             SD()          open an existing HDF file or create a new one,</span>
<span class="sd">                           returning an SD instance</span>
<span class="sd">             attr()        create an SDAttr (attribute) instance to access</span>
<span class="sd">                           an existing file attribute or create a new one;</span>
<span class="sd">                           &quot;dot notation&quot; can also be used to get and set</span>
<span class="sd">                           an attribute</span>
<span class="sd">             create()      create a new dataset, returning an SDS instance</span>
<span class="sd">             select()      locate an existing dataset given its name or</span>
<span class="sd">                           index number, returning an SDS instance</span>

<span class="sd">           file closing</span>
<span class="sd">             end()         end access to the SD interface and close the</span>
<span class="sd">                           HDF file</span>

<span class="sd">           inquiry</span>
<span class="sd">             attributes()  return a dictionnary describing every global</span>
<span class="sd">                           attribute attached to the HDF file</span>
<span class="sd">             datasets()    return a dictionnary describing every dataset</span>
<span class="sd">                           stored inside the file</span>
<span class="sd">             info()        get the number of datasets stored in the file</span>
<span class="sd">                           and the number of attributes attached to it</span>
<span class="sd">             nametoindex() get a dataset index number given the dataset</span>
<span class="sd">                           name</span>
<span class="sd">             reftoindex()  get a dataset index number given the dataset</span>
<span class="sd">                           reference number</span>

<span class="sd">           misc</span>
<span class="sd">             setfillmode() set the fill mode for all the datasets in</span>
<span class="sd">                           the file</span>


<span class="sd">  SDAttr The SDAttr class defines an attribute, either at the file (SD),</span>
<span class="sd">         dataset (SDS) or dimension (SDim) level. The class encapsulates</span>
<span class="sd">         the object to which the attribute is attached, and the attribute</span>
<span class="sd">         name.</span>

<span class="sd">         To create an SDAttr instance, obtain an instance for an SD (file),</span>
<span class="sd">         SDS (dataset) or dimension (SDim) object, and call its attr()</span>
<span class="sd">         method.</span>

<span class="sd">         NOTE. An attribute can also be read/written like</span>
<span class="sd">               a python class attribute, using the familiar</span>
<span class="sd">               dot notation. See &quot;High level attribute access&quot;.</span>

<span class="sd">         methods:</span>
<span class="sd">           read/write value</span>
<span class="sd">             get()         get the attribute value</span>
<span class="sd">             set()         set the attribute value</span>


<span class="sd">           inquiry</span>
<span class="sd">             index()       get the attribute index number</span>
<span class="sd">             info()        get the attribute name, type and number of</span>
<span class="sd">                           values</span>


<span class="sd">  SDC    The SDC class holds contants defining file opening modes and</span>
<span class="sd">         data types. Constants are named after their C API counterparts.</span>

<span class="sd">           file opening modes:</span>
<span class="sd">             SDC.CREATE      create file if non existent</span>
<span class="sd">             SDC.READ        read-only mode</span>
<span class="sd">             SDC.TRUNC       truncate file if already exists</span>
<span class="sd">             SDC.WRITE       read-write mode</span>

<span class="sd">           data types:</span>
<span class="sd">             SDC.CHAR        8-bit character</span>
<span class="sd">             SDC.CHAR8       8-bit character</span>
<span class="sd">             SDC.UCHAR       unsigned 8-bit integer</span>
<span class="sd">             SDC.UCHAR8      unsigned 8-bit integer</span>
<span class="sd">             SDC.INT8        signed 8-bit integer</span>
<span class="sd">             SDC.UINT8       unsigned 8-bit integer</span>
<span class="sd">             SDC.INT16       signed 16-bit integer</span>
<span class="sd">             SDC.UINT16      unsigned 16-bit intege</span>
<span class="sd">             SDC.INT32       signed 32-bit integer</span>
<span class="sd">             SDC.UINT32      unsigned 32-bit integer</span>
<span class="sd">             SDC.FLOAT32     32-bit floating point</span>
<span class="sd">             SDC.FLOAT64     64-bit floaring point</span>

<span class="sd">           dataset fill mode:</span>
<span class="sd">             SDC.FILL</span>
<span class="sd">             SDC.NOFILL</span>

<span class="sd">           dimension:</span>
<span class="sd">             SDC.UNLIMITED   dimension can grow dynamically</span>

<span class="sd">           data compression:</span>
<span class="sd">             SDC.COMP_NONE</span>
<span class="sd">             SDC.COMP_RLE</span>
<span class="sd">             SDC.COMP_NBIT</span>
<span class="sd">             SDC.COMP_SKPHUFF</span>
<span class="sd">             SDC.COMP_DEFLATE</span>
<span class="sd">             SDC.COMP_SZIP</span>
<span class="sd">             SDC.COMP_SZIP_EC</span>
<span class="sd">             SDC.COMP_SZIP_NN</span>
<span class="sd">             SDC.COMP_SZIP_RAW</span>

<span class="sd">  SDS    The SDS class implements an HDF scientific dataset (SDS) object.</span>

<span class="sd">         To create an SDS instance, call the create() or select() methods</span>
<span class="sd">         of an SD instance.</span>

<span class="sd">         methods:</span>
<span class="sd">           constructors</span>
<span class="sd">             attr()        create an SDAttr (attribute) instance to access</span>
<span class="sd">                           an existing dataset attribute or create a</span>
<span class="sd">                           new one; &quot;dot notation&quot; can also be used to get</span>
<span class="sd">                           and set an attribute</span>

<span class="sd">             dim()         return an SDim (dimension) instance for a given</span>
<span class="sd">                           dataset dimension, given the dimension index</span>
<span class="sd">                           number</span>

<span class="sd">           dataset closing</span>
<span class="sd">             endaccess()   terminate access to the dataset</span>

<span class="sd">           inquiry</span>
<span class="sd">             attributes()  return a dictionnary describing every</span>
<span class="sd">                           attribute defined on the dataset</span>
<span class="sd">             checkempty()  determine whether the dataset is empty</span>
<span class="sd">             dimensions()  return a dictionnary describing all the</span>
<span class="sd">                           dataset dimensions</span>
<span class="sd">             info()        get the dataset name, rank, dimension lengths,</span>
<span class="sd">                           data type and number of attributes</span>
<span class="sd">             iscoordvar()  determine whether the dataset is a coordinate</span>
<span class="sd">                           variable (holds a dimension scale)</span>
<span class="sd">             isrecord()    determine whether the dataset is appendable</span>
<span class="sd">                           (the dataset dimension 0 is unlimited)</span>
<span class="sd">             ref()         get the dataset reference number</span>


<span class="sd">           reading/writing data values</span>
<span class="sd">             get()         read data from the dataset</span>
<span class="sd">             set()         write data to the dataset</span>

<span class="sd">                           A dataset can also be read/written using the</span>
<span class="sd">                           familiar index and slice notation used to</span>
<span class="sd">                           access python sequences. See &quot;High level</span>
<span class="sd">                           variable access&quot;.</span>

<span class="sd">           reading/writing  standard attributes</span>
<span class="sd">             getcal()       get the dataset calibration coefficients:</span>
<span class="sd">                              scale_factor, scale_factor_err, add_offset,</span>
<span class="sd">                              add_offset_err, calibrated_nt</span>
<span class="sd">             getdatastrs()  get the dataset standard string attributes:</span>
<span class="sd">                              long_name, units, format, coordsys</span>
<span class="sd">             getfillvalue() get the dataset fill value:</span>
<span class="sd">                              _FillValue</span>
<span class="sd">             getrange()     get the dataset min and max values:</span>
<span class="sd">                              valid_range</span>
<span class="sd">             setcal()       set the dataset calibration coefficients</span>
<span class="sd">             setdatastrs()  set the dataset standard string attributes</span>
<span class="sd">             setfillvalue() set the dataset fill value</span>
<span class="sd">             setrange()     set the dataset min and max values</span>

<span class="sd">           compression</span>
<span class="sd">             getcompress()  get info about the dataset compression type and mode</span>
<span class="sd">             setcompress()  set the dataset compression type and mode</span>

<span class="sd">           misc</span>
<span class="sd">             setexternalfile()  store the dataset in an external file</span>

<span class="sd">  SDim   The SDdim class implements a dimension object.</span>

<span class="sd">         To create an SDim instance, call the dim() method of an SDS</span>
<span class="sd">         (dataset) instance.</span>

<span class="sd">         Methods:</span>
<span class="sd">           constructors</span>
<span class="sd">             attr()         create an SDAttr (attribute) instance to access</span>
<span class="sd">                            an existing dimension attribute or create a</span>
<span class="sd">                            new one; &quot;dot notation&quot; can also be used to</span>
<span class="sd">                            get and set an attribute</span>

<span class="sd">           inquiry</span>
<span class="sd">             attributes()   return a dictionnary describing every</span>
<span class="sd">                            attribute defined on the dimension</span>
<span class="sd">             info()         get the dimension name, length, scale data type</span>
<span class="sd">                            and number of attributes</span>
<span class="sd">             length()       return the current dimension length</span>

<span class="sd">           reading/writing dimension data</span>
<span class="sd">             getscale()     get the dimension scale values</span>
<span class="sd">             setname()      set the dimension name</span>
<span class="sd">             setscale()     set the dimension scale values</span>

<span class="sd">           reading/writing standard attributes</span>
<span class="sd">             getstrs()      get the dimension standard string attributes:</span>
<span class="sd">                              long_name, units, format</span>
<span class="sd">             setstrs()      set the dimension standard string attributes</span>

<span class="sd">Data types</span>
<span class="sd">----------</span>
<span class="sd">Data types come into play when first defining datasets and their attributes,</span>
<span class="sd">and later when querying the definition of those objects.</span>
<span class="sd">Data types are specified using the symbolic constants defined inside the</span>
<span class="sd">SDC class of the SD module.</span>

<span class="sd">- CHAR and CHAR8 (equivalent): an 8-bit character.</span>
<span class="sd">- UCHAR, UCHAR8 and UINT8 (equivalent): unsigned 8-bit values (0 to 255)</span>
<span class="sd">- INT8:    signed 8-bit values (-128 to 127)</span>
<span class="sd">- INT16:   signed 16-bit values</span>
<span class="sd">- UINT16:  unsigned 16 bit values</span>
<span class="sd">- INT32:   signed 32 bit values</span>
<span class="sd">- UINT32:  unsigned 32 bit values</span>
<span class="sd">- FLOAT32: 32 bit floating point values (C floats)</span>
<span class="sd">- FLOAT64: 64 bit floating point values (C doubles)</span>

<span class="sd">There is no explicit &quot;string&quot; type. To simulate a string, set the</span>
<span class="sd">type to CHAR, and set the length to a value of &#39;n&#39; &gt; 1. This creates and</span>
<span class="sd">&quot;array of characters&quot;, close to a string (except that strings will always</span>
<span class="sd">be of length &#39;n&#39;, right-padded with spaces if necessary).</span>


<span class="sd">Programming models</span>
<span class="sd">------------------</span>

<span class="sd">Writing</span>
<span class="sd">^^^^^^^</span>
<span class="sd">The following code can be used as a model to create an SD dataset.</span>
<span class="sd">It shows how to use the most important functionnalities</span>
<span class="sd">of the SD interface needed to initialize a dataset.</span>
<span class="sd">A real program should of course add error handling::</span>

<span class="sd">    # Import SD and numpy.</span>
<span class="sd">    from pyhdf.SD import *</span>
<span class="sd">    from numpy import *</span>

<span class="sd">    fileName = &#39;template.hdf&#39;</span>
<span class="sd">    # Create HDF file.</span>
<span class="sd">    hdfFile = SD(fileName ,SDC.WRITE|SDC.CREATE)</span>
<span class="sd">    # Assign a few attributes at the file level</span>
<span class="sd">    hdfFile.author = &#39;It is me...&#39;</span>
<span class="sd">    hdfFile.priority = 2</span>
<span class="sd">    # Create a dataset named &#39;d1&#39; to hold a 3x3 float array.</span>
<span class="sd">    d1 = hdfFile.create(&#39;d1&#39;, SDC.FLOAT32, (3,3))</span>
<span class="sd">    # Set some attributs on &#39;d1&#39;</span>
<span class="sd">    d1.description = &#39;Sample 3x3 float array&#39;</span>
<span class="sd">    d1.units = &#39;celsius&#39;</span>
<span class="sd">    # Name &#39;d1&#39; dimensions and assign them attributes.</span>
<span class="sd">    dim1 = d1.dim(0)</span>
<span class="sd">    dim2 = d1.dim(1)</span>
<span class="sd">    dim1.setname(&#39;width&#39;)</span>
<span class="sd">    dim2.setname(&#39;height&#39;)</span>
<span class="sd">    dim1.units = &#39;m&#39;</span>
<span class="sd">    dim2.units = &#39;cm&#39;</span>
<span class="sd">    # Assign values to &#39;d1&#39;</span>
<span class="sd">    d1[0]  = (14.5, 12.8, 13.0)  # row 1</span>
<span class="sd">    d1[1:] = ((-1.3, 0.5, 4.8),  # row 2 and</span>
<span class="sd">              (3.1, 0.0, 13.8))  # row 3</span>
<span class="sd">    # Close dataset</span>
<span class="sd">    d1.endaccess()</span>
<span class="sd">    # Close file</span>
<span class="sd">    hdfFile.end()</span>

<span class="sd">Reading</span>
<span class="sd">^^^^^^^</span>
<span class="sd">The following code, which reads the dataset created above, can also serve as</span>
<span class="sd">a model for any program which needs to access an SD dataset::</span>

<span class="sd">    # Import SD and numpy.</span>
<span class="sd">    from pyhdf.SD import *</span>
<span class="sd">    from numpy import *</span>

<span class="sd">    fileName = &#39;template.hdf&#39;</span>
<span class="sd">    # Open file in read-only mode (default)</span>
<span class="sd">    hdfFile = SD(fileName)</span>
<span class="sd">    # Display attributes.</span>
<span class="sd">    print &quot;file:&quot;, fileName</span>
<span class="sd">    print &quot;author:&quot;, hdfFile.author</span>
<span class="sd">    print &quot;priority:&quot;, hdfFile.priority</span>
<span class="sd">    # Open dataset &#39;d1&#39;</span>
<span class="sd">    d1 = hdfFile.select(&#39;d1&#39;)</span>
<span class="sd">    # Display dataset attributes.</span>
<span class="sd">    print &quot;dataset:&quot;, &#39;d1&#39;</span>
<span class="sd">    print &quot;description:&quot;,d1.description</span>
<span class="sd">    print &quot;units:&quot;, d1.units</span>
<span class="sd">    # Display dimensions info.</span>
<span class="sd">    dim1 = d1.dim(0)</span>
<span class="sd">    dim2 = d1.dim(1)</span>
<span class="sd">    print &quot;dimensions:&quot;</span>
<span class="sd">    print &quot;dim1: name=&quot;, dim1.info()[0],</span>
<span class="sd">    print &quot;length=&quot;, dim1.length(),</span>
<span class="sd">    print &quot;units=&quot;, dim1.units</span>
<span class="sd">    print &quot;dim2: name=&quot;, dim2.info()[0],</span>
<span class="sd">    print &quot;length=&quot;, dim2.length(),</span>
<span class="sd">    print &quot;units=&quot;, dim2.units</span>
<span class="sd">    # Show dataset values</span>
<span class="sd">    print d1[:]</span>
<span class="sd">    # Close dataset</span>
<span class="sd">    d1.endaccess()</span>
<span class="sd">    # Close file</span>
<span class="sd">    hdfFile.end()</span>


<span class="sd">Examples</span>
<span class="sd">--------</span>

<span class="sd">Example-1</span>
<span class="sd">^^^^^^^^^</span>
<span class="sd">The following simple example exercises some important pyhdf.SD methods. It</span>
<span class="sd">shows how to create an HDF dataset, define attributes and dimensions,</span>
<span class="sd">create variables, and assign their contents.</span>

<span class="sd">Suppose we have a series of text files each defining a 2-dimensional real-</span>
<span class="sd">valued matrix. First line holds the matrix dimensions, and following lines</span>
<span class="sd">hold matrix values, one row per line. The following procedure will load</span>
<span class="sd">into an HDF dataset the contents of any one of those text files. The</span>
<span class="sd">procedure computes the matrix min and max values, storing them as</span>
<span class="sd">dataset attributes. It also assigns to the variable the group of</span>
<span class="sd">attributes passed as a dictionnary by the calling program. Note how simple</span>
<span class="sd">such an assignment becomes with pyhdf: the dictionnary can contain any</span>
<span class="sd">number of attributes, of different types, single or multi-valued. Doing</span>
<span class="sd">the same in a conventional language would be a much more challenging task.</span>

<span class="sd">Error checking is minimal, to keep example as simple as possible</span>
<span class="sd">(admittedly a rather poor excuse ...)::</span>

<span class="sd">    from numpy import *</span>
<span class="sd">    from pyhdf.SD import *</span>

<span class="sd">    import os</span>

<span class="sd">    def txtToHDF(txtFile, hdfFile, varName, attr):</span>

<span class="sd">        try:  # Catch pyhdf errors</span>
<span class="sd">            # Open HDF file in update mode, creating it if non existent.</span>
<span class="sd">            d = SD(hdfFile, SDC.WRITE|SDC.CREATE)</span>
<span class="sd">            # Open text file and get matrix dimensions on first line.</span>
<span class="sd">            txt = open(txtFile)</span>
<span class="sd">            ni, nj = map(int, txt.readline().split())</span>
<span class="sd">            # Define an HDF dataset of 32-bit floating type (SDC.FLOAT32)</span>
<span class="sd">            # with those dimensions.</span>
<span class="sd">            v = d.create(varName, SDC.FLOAT32, (ni, nj))</span>
<span class="sd">            # Assign attributes passed as argument inside dict &#39;attr&#39;.</span>
<span class="sd">            for attrName in attr.keys():</span>
<span class="sd">                setattr(v, attrName, attr[attrName])</span>
<span class="sd">            # Load variable with lines of data. Compute min and max</span>
<span class="sd">            # over the whole matrix.</span>
<span class="sd">            i = 0</span>
<span class="sd">            while i &lt; ni:</span>
<span class="sd">                elems = map(float, txt.readline().split())</span>
<span class="sd">                v[i] = elems  # load row i</span>
<span class="sd">                minE = min(elems)</span>
<span class="sd">                maxE = max(elems)</span>
<span class="sd">                if i:</span>
<span class="sd">                    minVal = min(minVal, minE)</span>
<span class="sd">                    maxVal = max(maxVal, maxE)</span>
<span class="sd">                else:</span>
<span class="sd">                    minVal = minE</span>
<span class="sd">                    maxVal = maxE</span>
<span class="sd">                i += 1</span>
<span class="sd">            # Set variable min and max attributes.</span>
<span class="sd">            v.minVal = minVal</span>
<span class="sd">            v.maxVal = maxVal</span>
<span class="sd">            # Close dataset and file objects (not really necessary, since</span>
<span class="sd">            # closing is automatic when objects go out of scope.</span>
<span class="sd">            v.endaccess()</span>
<span class="sd">            d.end()</span>
<span class="sd">            txt.close()</span>
<span class="sd">        except HDF4Error, msg:</span>
<span class="sd">            print &quot;HDF4Error:&quot;, msg</span>


<span class="sd">We could now call the procedure as follows::</span>

<span class="sd">    hdfFile  = &#39;table.hdf&#39;</span>
<span class="sd">    try:  # Delete if exists.</span>
<span class="sd">        os.remove(hdfFile)</span>
<span class="sd">    except:</span>
<span class="sd">        pass</span>
<span class="sd">    # Load contents of file &#39;temp.txt&#39; into dataset &#39;temperature&#39;</span>
<span class="sd">    # an assign the attributes &#39;title&#39;, &#39;units&#39; and &#39;valid_range&#39;.</span>
<span class="sd">    txtToHDF(&#39;temp.txt&#39;, hdfFile, &#39;temperature&#39;,</span>
<span class="sd">             {&#39;title&#39;      : &#39;temperature matrix&#39;,</span>
<span class="sd">              &#39;units&#39;      : &#39;celsius&#39;,</span>
<span class="sd">              &#39;valid_range&#39;: (-2.8,27.0)})</span>

<span class="sd">    # Load contents of file &#39;depth.txt&#39; into dataset &#39;depth&#39;</span>
<span class="sd">    # and assign the same attributes as above.</span>
<span class="sd">    txtToHDF(&#39;depth.txt&#39;, hdfFile, &#39;depth&#39;,</span>
<span class="sd">             {&#39;title&#39;      : &#39;depth matrix&#39;,</span>
<span class="sd">              &#39;units&#39;      : &#39;meters&#39;,</span>
<span class="sd">              &#39;valid_range&#39;: (0, 500.0)})</span>


<span class="sd">Example 2</span>
<span class="sd">^^^^^^^^^</span>
<span class="sd">This example shows a usefull python program that will display the</span>
<span class="sd">structure of the SD component of any HDF file whose name is given on</span>
<span class="sd">the command line. After the HDF file is opened, high level inquiry methods</span>
<span class="sd">are called to obtain dictionnaries descrybing attributes, dimensions and</span>
<span class="sd">datasets. The rest of the program mostly consists in nicely formatting</span>
<span class="sd">the contents of those dictionaries::</span>

<span class="sd">    import sys</span>
<span class="sd">    from pyhdf.SD import *</span>
<span class="sd">    from numpy import *</span>

<span class="sd">    # Dictionnary used to convert from a numeric data type to its symbolic</span>
<span class="sd">    # representation</span>
<span class="sd">    typeTab = {</span>
<span class="sd">               SDC.CHAR:    &#39;CHAR&#39;,</span>
<span class="sd">               SDC.CHAR8:   &#39;CHAR8&#39;,</span>
<span class="sd">               SDC.UCHAR8:  &#39;UCHAR8&#39;,</span>
<span class="sd">               SDC.INT8:    &#39;INT8&#39;,</span>
<span class="sd">               SDC.UINT8:   &#39;UINT8&#39;,</span>
<span class="sd">               SDC.INT16:   &#39;INT16&#39;,</span>
<span class="sd">               SDC.UINT16:  &#39;UINT16&#39;,</span>
<span class="sd">               SDC.INT32:   &#39;INT32&#39;,</span>
<span class="sd">               SDC.UINT32:  &#39;UINT32&#39;,</span>
<span class="sd">               SDC.FLOAT32: &#39;FLOAT32&#39;,</span>
<span class="sd">               SDC.FLOAT64: &#39;FLOAT64&#39;</span>
<span class="sd">               }</span>

<span class="sd">    printf = sys.stdout.write</span>

<span class="sd">    def eol(n=1):</span>
<span class="sd">        printf(&quot;%s&quot; % chr(10) * n)</span>

<span class="sd">    hdfFile = sys.argv[1]    # Get first command line argument</span>

<span class="sd">    try:  # Catch pyhdf.SD errors</span>
<span class="sd">      # Open HDF file named on the command line</span>
<span class="sd">      f = SD(hdfFile)</span>
<span class="sd">      # Get global attribute dictionnary</span>
<span class="sd">      attr = f.attributes(full=1)</span>
<span class="sd">      # Get dataset dictionnary</span>
<span class="sd">      dsets = f.datasets()</span>

<span class="sd">      # File name, number of attributes and number of variables.</span>
<span class="sd">      printf(&quot;FILE INFO&quot;); eol()</span>
<span class="sd">      printf(&quot;-------------&quot;); eol()</span>
<span class="sd">      printf(&quot;%-25s%s&quot; % (&quot;File:&quot;, hdfFile)); eol()</span>
<span class="sd">      printf(&quot;%-25s%d&quot; % (&quot;  file attributes:&quot;, len(attr))); eol()</span>
<span class="sd">      printf(&quot;%-25s%d&quot; % (&quot;  datasets:&quot;, len(dsets))); eol()</span>
<span class="sd">      eol();</span>

<span class="sd">      # Global attribute table.</span>
<span class="sd">      if len(attr) &gt; 0:</span>
<span class="sd">          printf(&quot;File attributes&quot;); eol(2)</span>
<span class="sd">          printf(&quot;  name                 idx type    len value&quot;); eol()</span>
<span class="sd">          printf(&quot;  -------------------- --- ------- --- -----&quot;); eol()</span>
<span class="sd">          # Get list of attribute names and sort them lexically</span>
<span class="sd">          attNames = attr.keys()</span>
<span class="sd">          attNames.sort()</span>
<span class="sd">          for name in attNames:</span>
<span class="sd">              t = attr[name]</span>
<span class="sd">                  # t[0] is the attribute value</span>
<span class="sd">                  # t[1] is the attribute index number</span>
<span class="sd">                  # t[2] is the attribute type</span>
<span class="sd">                  # t[3] is the attribute length</span>
<span class="sd">              printf(&quot;  %-20s %3d %-7s %3d %s&quot; %</span>
<span class="sd">                     (name, t[1], typeTab[t[2]], t[3], t[0])); eol()</span>
<span class="sd">          eol()</span>


<span class="sd">      # Dataset table</span>
<span class="sd">      if len(dsets) &gt; 0:</span>
<span class="sd">          printf(&quot;Datasets (idx:index num, na:n attributes, cv:coord var)&quot;); eol(2)</span>
<span class="sd">          printf(&quot;  name                 idx type    na cv dimension(s)&quot;); eol()</span>
<span class="sd">          printf(&quot;  -------------------- --- ------- -- -- ------------&quot;); eol()</span>
<span class="sd">          # Get list of dataset names and sort them lexically</span>
<span class="sd">          dsNames = dsets.keys()</span>
<span class="sd">          dsNames.sort()</span>
<span class="sd">          for name in dsNames:</span>
<span class="sd">              # Get dataset instance</span>
<span class="sd">              ds = f.select(name)</span>
<span class="sd">              # Retrieve the dictionary of dataset attributes so as</span>
<span class="sd">              # to display their number</span>
<span class="sd">              vAttr = ds.attributes()</span>
<span class="sd">              t = dsets[name]</span>
<span class="sd">                  # t[0] is a tuple of dimension names</span>
<span class="sd">                  # t[1] is a tuple of dimension lengths</span>
<span class="sd">                  # t[2] is the dataset type</span>
<span class="sd">                  # t[3] is the dataset index number</span>
<span class="sd">              printf(&quot;  %-20s %3d %-7s %2d %-2s &quot; %</span>
<span class="sd">                     (name, t[3], typeTab[t[2]], len(vAttr),</span>
<span class="sd">                      ds.iscoordvar() and &#39;X&#39; or &#39;&#39;))</span>
<span class="sd">              # Display dimension info.</span>
<span class="sd">              n = 0</span>
<span class="sd">              for d in t[0]:</span>
<span class="sd">                  printf(&quot;%s%s(%d)&quot; % (n &gt; 0 and &#39;, &#39; or &#39;&#39;, d, t[1][n]))</span>
<span class="sd">                  n += 1</span>
<span class="sd">              eol()</span>
<span class="sd">          eol()</span>

<span class="sd">      # Dataset info.</span>
<span class="sd">      if len(dsNames) &gt; 0:</span>
<span class="sd">          printf(&quot;DATASET INFO&quot;); eol()</span>
<span class="sd">          printf(&quot;-------------&quot;); eol(2)</span>
<span class="sd">          for name in dsNames:</span>
<span class="sd">              # Access the dataset</span>
<span class="sd">              dsObj = f.select(name)</span>
<span class="sd">              # Get dataset attribute dictionnary</span>
<span class="sd">              dsAttr = dsObj.attributes(full=1)</span>
<span class="sd">              if len(dsAttr) &gt; 0:</span>
<span class="sd">                  printf(&quot;%s attributes&quot; % name); eol(2)</span>
<span class="sd">                  printf(&quot;  name                 idx type    len value&quot;); eol()</span>
<span class="sd">                  printf(&quot;  -------------------- --- ------- --- -----&quot;); eol()</span>
<span class="sd">                  # Get the list of attribute names and sort them alphabetically.</span>
<span class="sd">                  attNames = dsAttr.keys()</span>
<span class="sd">                  attNames.sort()</span>
<span class="sd">                  for nm in attNames:</span>
<span class="sd">                      t = dsAttr[nm]</span>
<span class="sd">                          # t[0] is the attribute value</span>
<span class="sd">                          # t[1] is the attribute index number</span>
<span class="sd">                          # t[2] is the attribute type</span>
<span class="sd">                          # t[3] is the attribute length</span>
<span class="sd">                      printf(&quot;  %-20s %3d %-7s %3d %s&quot; %</span>
<span class="sd">                             (nm, t[1], typeTab[t[2]], t[3], t[0])); eol()</span>
<span class="sd">                  eol()</span>
<span class="sd">              # Get dataset dimension dictionnary</span>
<span class="sd">              dsDim = dsObj.dimensions(full=1)</span>
<span class="sd">              if len(dsDim) &gt; 0:</span>
<span class="sd">                  printf (&quot;%s dimensions&quot; % name); eol(2)</span>
<span class="sd">                  printf(&quot;  name                 idx len   unl type    natt&quot;);eol()</span>
<span class="sd">                  printf(&quot;  -------------------- --- ----- --- ------- ----&quot;);eol()</span>
<span class="sd">                  # Get the list of dimension names and sort them alphabetically.</span>
<span class="sd">                  dimNames = dsDim.keys()</span>
<span class="sd">                  dimNames.sort()</span>
<span class="sd">                  for nm in dimNames:</span>
<span class="sd">                      t = dsDim[nm]</span>
<span class="sd">                          # t[0] is the dimension length</span>
<span class="sd">                          # t[1] is the dimension index number</span>
<span class="sd">                          # t[2] is 1 if the dimension is unlimited, 0 if not</span>
<span class="sd">                          # t[3] is the the dimension scale type, 0 if no scale</span>
<span class="sd">                          # t[4] is the number of attributes</span>
<span class="sd">                      printf(&quot;  %-20s %3d %5d  %s  %-7s %4d&quot; %</span>
<span class="sd">                             (nm, t[1], t[0], t[2] and &quot;X&quot; or &quot; &quot;,</span>
<span class="sd">                              t[3] and typeTab[t[3]] or &quot;&quot;, t[4])); eol()</span>
<span class="sd">                  eol()</span>


<span class="sd">    except HDF4Error, msg:</span>
<span class="sd">        print &quot;HDF4Error&quot;, msg</span>



<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">types</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">hdfext</span> <span class="k">as</span> <span class="n">_C</span>
<span class="kn">from</span> <span class="nn">.six.moves</span> <span class="k">import</span> <span class="n">xrange</span>
<span class="kn">from</span> <span class="nn">.error</span> <span class="k">import</span> <span class="n">_checkErr</span><span class="p">,</span> <span class="n">HDF4Error</span>

<span class="c1"># List of names we want to be imported by an &quot;from pyhdf.SD import *&quot;</span>
<span class="c1"># statement</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;SD&#39;</span><span class="p">,</span> <span class="s1">&#39;SDAttr&#39;</span><span class="p">,</span> <span class="s1">&#39;SDC&#39;</span><span class="p">,</span> <span class="s1">&#39;SDS&#39;</span><span class="p">,</span> <span class="s1">&#39;SDim&#39;</span><span class="p">,</span> <span class="s1">&#39;HDF4Error&#39;</span><span class="p">]</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">_toto</span>
    <span class="k">del</span> <span class="n">_toto</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;numpy package required but not installed&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="SDC"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDC">[docs]</a><span class="k">class</span> <span class="nc">SDC</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The SDC class holds contants defining opening modes and data types.</span>

<span class="sd">           file opening modes:</span>
<span class="sd">             ==========   ===    ===============================</span>
<span class="sd">             SDC.CREATE     4    create file if non existent</span>
<span class="sd">             SDC.READ       1    read-only mode</span>
<span class="sd">             SDC.TRUNC    256    truncate file if already exists</span>
<span class="sd">             SDC.WRITE      2    read-write mode</span>
<span class="sd">             ==========   ===    ===============================</span>

<span class="sd">           data types:</span>
<span class="sd">             ===========  ===    ===============================</span>
<span class="sd">             SDC.CHAR       4    8-bit character</span>
<span class="sd">             SDC.CHAR8      4    8-bit character</span>
<span class="sd">             SDC.UCHAR      3    unsigned 8-bit integer</span>
<span class="sd">             SDC.UCHAR8     3    unsigned 8-bit integer</span>
<span class="sd">             SDC.INT8      20    signed 8-bit integer</span>
<span class="sd">             SDC.UINT8     21    unsigned 8-bit integer</span>
<span class="sd">             SDC.INT16     22    signed 16-bit integer</span>
<span class="sd">             SDC.UINT16    23    unsigned 16-bit intege</span>
<span class="sd">             SDC.INT32     24    signed 32-bit integer</span>
<span class="sd">             SDC.UINT32    25    unsigned 32-bit integer</span>
<span class="sd">             SDC.FLOAT32    5    32-bit floating point</span>
<span class="sd">             SDC.FLOAT64    6    64-bit floaring point</span>
<span class="sd">             ===========  ===    ===============================</span>

<span class="sd">           dataset fill mode:</span>
<span class="sd">             ===========  ===</span>
<span class="sd">             SDC.FILL       0</span>
<span class="sd">             SDC.NOFILL   256</span>
<span class="sd">             ===========  ===</span>

<span class="sd">           dimension:</span>
<span class="sd">             =============  ===  ===============================</span>
<span class="sd">             SDC.UNLIMITED  0    dimension can grow dynamically</span>
<span class="sd">             =============  ===  ===============================</span>

<span class="sd">           data compression:</span>
<span class="sd">             =================  ===</span>
<span class="sd">             SDC.COMP_NONE      0</span>
<span class="sd">             SDC.COMP_RLE       1</span>
<span class="sd">             SDC.COMP_NBIT      2</span>
<span class="sd">             SDC.COMP_SKPHUFF   3</span>
<span class="sd">             SDC.COMP_DEFLATE   4</span>
<span class="sd">             SDC.COMP_SZIP      5</span>

<span class="sd">             SDC.COMP_SZIP_EC     4</span>
<span class="sd">             SDC.COMP_SZIP_NN    32</span>
<span class="sd">             SDC.COMP_SZIP_RAW  128</span>
<span class="sd">             =================  ===</span>

<span class="sd">&quot;&quot;&quot;</span>

    <span class="n">CREATE</span>       <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">DFACC_CREATE</span>
    <span class="n">READ</span>         <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">DFACC_READ</span>
    <span class="n">TRUNC</span>        <span class="o">=</span> <span class="mh">0x100</span>          <span class="c1"># specific to pyhdf</span>
    <span class="n">WRITE</span>        <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">DFACC_WRITE</span>

    <span class="n">CHAR</span>         <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">DFNT_CHAR8</span>
    <span class="n">CHAR8</span>        <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">DFNT_CHAR8</span>
    <span class="n">UCHAR</span>        <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">DFNT_UCHAR8</span>
    <span class="n">UCHAR8</span>       <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">DFNT_UCHAR8</span>
    <span class="n">INT8</span>         <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">DFNT_INT8</span>
    <span class="n">UINT8</span>        <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">DFNT_UINT8</span>
    <span class="n">INT16</span>        <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">DFNT_INT16</span>
    <span class="n">UINT16</span>       <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">DFNT_UINT16</span>
    <span class="n">INT32</span>        <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">DFNT_INT32</span>
    <span class="n">UINT32</span>       <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">DFNT_UINT32</span>
    <span class="n">FLOAT32</span>      <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">DFNT_FLOAT32</span>
    <span class="n">FLOAT64</span>      <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">DFNT_FLOAT64</span>

    <span class="n">FILL</span>         <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SD_FILL</span>
    <span class="n">NOFILL</span>       <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SD_NOFILL</span>

    <span class="n">UNLIMITED</span>    <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SD_UNLIMITED</span>

    <span class="n">COMP_NONE</span>    <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">COMP_CODE_NONE</span>
    <span class="n">COMP_RLE</span>     <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">COMP_CODE_RLE</span>
    <span class="n">COMP_NBIT</span>    <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">COMP_CODE_NBIT</span>
    <span class="n">COMP_SKPHUFF</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">COMP_CODE_SKPHUFF</span>
    <span class="n">COMP_DEFLATE</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">COMP_CODE_DEFLATE</span>
    <span class="n">COMP_SZIP</span>    <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">COMP_CODE_SZIP</span>

    <span class="n">COMP_SZIP_EC</span>  <span class="o">=</span>   <span class="mi">4</span>
    <span class="n">COMP_SZIP_NN</span>  <span class="o">=</span>  <span class="mi">32</span>
    <span class="n">COMP_SZIP_RAW</span> <span class="o">=</span> <span class="mi">128</span>

    <span class="c1"># Types with an equivalent in the numpy package</span>
    <span class="c1"># NOTE:</span>
    <span class="c1">#  CHAR8 and INT8 are handled similarly (signed byte -128,...,0,...127)</span>
    <span class="c1">#  UCHAR8 and UINT8 are treated equivalently (unsigned byte: 0,1,...,255)</span>
    <span class="c1">#  UINT16 and UINT32 are supported</span>
    <span class="c1">#  INT64 and UINT64 are not yet supported py pyhdf</span>
    <span class="n">equivNumericTypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">FLOAT32</span><span class="p">,</span> <span class="n">FLOAT64</span><span class="p">,</span>
                         <span class="n">INT8</span><span class="p">,</span> <span class="n">UINT8</span><span class="p">,</span>
                         <span class="n">INT16</span><span class="p">,</span> <span class="n">UINT16</span><span class="p">,</span>
                         <span class="n">INT32</span><span class="p">,</span> <span class="n">UINT32</span><span class="p">,</span>
                         <span class="n">CHAR8</span><span class="p">,</span> <span class="n">UCHAR8</span><span class="p">]</span></div>

<div class="viewcode-block" id="SDAttr"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDAttr">[docs]</a><span class="k">class</span> <span class="nc">SDAttr</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">index_or_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Init an SDAttr instance. Should not be called directly by</span>
<span class="sd">        the user program. An SDAttr instance must be created through</span>
<span class="sd">        the attr() methods of the SD, SDS or SDim classes.</span>
<span class="sd">                                                &quot;&quot;&quot;</span>
        <span class="c1"># Args</span>
        <span class="c1">#  obj   object instance to which the attribute refers</span>
        <span class="c1">#        (SD, SDS, SDDim)</span>
        <span class="c1">#  index_or_name attribute index or name</span>
        <span class="c1">#</span>
        <span class="c1"># Class private attributes:</span>
        <span class="c1">#  _obj   object instance</span>
        <span class="c1">#  _index attribute index or None</span>
        <span class="c1">#  _name  attribute name or None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="c1"># Name is given, may exist or not.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index_or_name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">index_or_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Index is given. Must exist.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">index_or_name</span>
            <span class="n">status</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">n_values</span> <span class="o">=</span> \
                    <span class="n">_C</span><span class="o">.</span><span class="n">SDattrinfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>
            <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;set&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;illegal attribute index&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="SDAttr.info"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDAttr.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve info about the attribute : name, data type and</span>
<span class="sd">        number of values.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          3-element tuple holding:</span>

<span class="sd">          - attribute name</span>
<span class="sd">          - attribute data type (see constants SDC.xxx)</span>
<span class="sd">          - number of values in the attribute; for a string-valued</span>
<span class="sd">            attribute (data type SDC.CHAR8), the number of values</span>
<span class="sd">            corresponds to the string length</span>


<span class="sd">        C library equivalent : SDattrinfo</span>
<span class="sd">                                                       &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">findattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">HDF4Error</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;info: cannot convert name to index&quot;</span><span class="p">)</span>
        <span class="n">status</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">n_values</span> <span class="o">=</span> \
                              <span class="n">_C</span><span class="o">.</span><span class="n">SDattrinfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;illegal attribute index&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">n_values</span></div>

<div class="viewcode-block" id="SDAttr.index"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDAttr.index">[docs]</a>    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve the attribute index number.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          attribute index number (starting at 0)</span>

<span class="sd">        C library equivalent : SDfindattr</span>
<span class="sd">                                             &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDfindattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;find&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="s1">&#39;illegal attribute name&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span></div>

<div class="viewcode-block" id="SDAttr.get"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDAttr.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve the attribute value.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          attribute value(s); a list is returned if the attribute</span>
<span class="sd">          is made up of more than one value, except in the case of a</span>
<span class="sd">          string-valued attribute (data type SDC.CHAR8) where the</span>
<span class="sd">          values are returned as a string</span>

<span class="sd">        C library equivalent : SDreadattr</span>

<span class="sd">        Attributes can also be read like ordinary python attributes,</span>
<span class="sd">        using the dot notation. See &quot;High level attribute access&quot;.</span>

<span class="sd">                                                &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">findattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">HDF4Error</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;get: cannot convert name to index&quot;</span><span class="p">)</span>

        <span class="c1"># Obtain attribute type and the number of values.</span>
        <span class="n">status</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">n_values</span> <span class="o">=</span> \
                    <span class="n">_C</span><span class="o">.</span><span class="n">SDattrinfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;read&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;illegal attribute index&#39;</span><span class="p">)</span>

        <span class="c1"># Get attribute value.</span>
        <span class="n">convert</span> <span class="o">=</span> <span class="n">_array_to_ret</span>
        <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">CHAR8</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">convert</span> <span class="o">=</span> <span class="n">_array_to_str</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SDC</span><span class="o">.</span><span class="n">UCHAR8</span><span class="p">,</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT8</span><span class="p">]:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT8</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int8</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT16</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT16</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">FLOAT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">FLOAT64</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float64</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;read: attribute index </span><span class="si">%d</span><span class="s2"> has an &quot;</span>\
                             <span class="s2">&quot;illegal or unupported type </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> \
                             <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="n">data_type</span><span class="p">))</span>

        <span class="n">status</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDreadattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;read&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;illegal attribute index&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">convert</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">n_values</span><span class="p">)</span></div>

<div class="viewcode-block" id="SDAttr.set"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDAttr.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update/Create a new attribute and set its value(s).</span>

<span class="sd">        Args::</span>

<span class="sd">          data_type    : attribute data type (see constants SDC.xxx)</span>
<span class="sd">          values       : attribute value(s); specify a list to create</span>
<span class="sd">                         a multi-valued attribute; a string valued</span>
<span class="sd">                         attribute can be created by setting &#39;data_type&#39;</span>
<span class="sd">                         to SDC.CHAR8 and &#39;values&#39; to the corresponding</span>
<span class="sd">                         string</span>

<span class="sd">        Returns::</span>

<span class="sd">          None</span>

<span class="sd">        C library equivalent : SDsetattr</span>

<span class="sd">        Attributes can also be written like ordinary python attributes,</span>
<span class="sd">        using the dot notation. See &quot;High level attribute access&quot;.</span>

<span class="sd">                                                  &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">n_values</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">n_values</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">CHAR8</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="c1"># Allow values to be passed as a string.</span>
            <span class="c1"># Noop if a list is passed.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_values</span><span class="p">):</span>
                <span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SDC</span><span class="o">.</span><span class="n">UCHAR8</span><span class="p">,</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT8</span><span class="p">]:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT8</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int8</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT16</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT16</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">FLOAT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">FLOAT64</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float64</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;set: illegal or unimplemented data_type&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_values</span><span class="p">):</span>
            <span class="n">buf</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDsetattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span>
                              <span class="n">data_type</span><span class="p">,</span> <span class="n">n_values</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;set&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;illegal attribute&#39;</span><span class="p">)</span>
        <span class="c1"># Init index following attribute creation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDfindattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;find&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="s1">&#39;illegal attribute&#39;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SD"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SD">[docs]</a><span class="k">class</span> <span class="nc">SD</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The SD class implements an HDF SD interface.</span>
<span class="sd">    To instantiate an SD class, call the SD() constructor.</span>
<span class="sd">    To set attributes on an SD instance, call the SD.attr()</span>
<span class="sd">    method to create an attribute instance, then call the methods</span>
<span class="sd">    of this instance. &quot;&quot;&quot;</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">SDC</span><span class="o">.</span><span class="n">READ</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;SD constructor. Initialize an SD interface on an HDF file,</span>
<span class="sd">        creating the file if necessary.</span>

<span class="sd">        Args::</span>

<span class="sd">          path    name of the HDF file on which to open the SD interface</span>
<span class="sd">          mode    file opening mode; this mode is a set of binary flags</span>
<span class="sd">                  which can be ored together</span>

<span class="sd">                      SDC.CREATE  combined with SDC.WRITE to create file</span>
<span class="sd">                                  if it does not exist</span>
<span class="sd">                      SDC.READ    open file in read-only access (default)</span>
<span class="sd">                      SDC.TRUNC   if combined with SDC.WRITE, overwrite</span>
<span class="sd">                                  file if it already exists</span>
<span class="sd">                      SDC.WRITE   open file in read-write mode; if file</span>
<span class="sd">                                  exists it is updated, unless SDC.TRUNC is</span>
<span class="sd">                                  set, in which case it is erased and</span>
<span class="sd">                                  recreated; if file does not exist, an</span>
<span class="sd">                                  error is raised unless SDC.CREATE is set,</span>
<span class="sd">                                  in which case the file is created</span>

<span class="sd">                   Note an important difference in the way CREATE is</span>
<span class="sd">                   handled by the C library and the pyhdf package.</span>
<span class="sd">                   For the C library, CREATE indicates that a new file</span>
<span class="sd">                   should always be created, overwriting an existing one if</span>
<span class="sd">                   any. For pyhdf, CREATE indicates a new file should be</span>
<span class="sd">                   created only if it does not exist, and the overwriting</span>
<span class="sd">                   of an already existing file must be explicitly asked</span>
<span class="sd">                   for by setting the TRUNC flag.</span>

<span class="sd">                   Those differences were introduced so as to harmonize</span>
<span class="sd">                   the way files are opened in the pycdf and pyhdf</span>
<span class="sd">                   packages. Also, this solves a limitation in the</span>
<span class="sd">                   hdf (and netCDF) library, where there is no easy way</span>
<span class="sd">                   to implement the frequent requirement that an existent</span>
<span class="sd">                   file be opened in read-write mode, or created</span>
<span class="sd">                   if it does not exist.</span>

<span class="sd">        Returns::</span>

<span class="sd">          an SD instance</span>

<span class="sd">        C library equivalent : SDstart</span>
<span class="sd">                                                     &quot;&quot;&quot;</span>
        <span class="c1"># Private attributes:</span>
        <span class="c1">#  _id:       file id</span>

        <span class="c1"># Make sure _id is initialized in case __del__ is called</span>
        <span class="c1"># when the SD object goes out of scope after failing to</span>
        <span class="c1"># open file. Failure to do so may put python into an infinite loop</span>
        <span class="c1"># (thanks to Richard.Andrews@esands.com for reporting this bug).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># See if file exists.</span>
        <span class="n">exists</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="c1"># We must have either WRITE or READ flag.</span>
        <span class="k">if</span> <span class="n">SDC</span><span class="o">.</span><span class="n">WRITE</span> <span class="o">&amp;</span> <span class="n">mode</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exists</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">SDC</span><span class="o">.</span><span class="n">TRUNC</span> <span class="o">&amp;</span> <span class="n">mode</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="n">mode</span> <span class="o">=</span> <span class="n">SDC</span><span class="o">.</span><span class="n">CREATE</span><span class="o">|</span><span class="n">SDC</span><span class="o">.</span><span class="n">WRITE</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mode</span> <span class="o">=</span> <span class="n">SDC</span><span class="o">.</span><span class="n">WRITE</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">SDC</span><span class="o">.</span><span class="n">CREATE</span> <span class="o">&amp;</span> <span class="n">mode</span><span class="p">:</span>
                    <span class="n">mode</span> <span class="o">|=</span> <span class="n">SDC</span><span class="o">.</span><span class="n">WRITE</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;SD: no such file&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">SDC</span><span class="o">.</span><span class="n">READ</span> <span class="o">&amp;</span> <span class="n">mode</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exists</span><span class="p">:</span>
                <span class="n">mode</span> <span class="o">=</span> <span class="n">SDC</span><span class="o">.</span><span class="n">READ</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;SD: no such file&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;SD: bad mode, READ or WRITE must be set&quot;</span><span class="p">)</span>

        <span class="nb">id</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDstart</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;SD&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="s2">&quot;cannot open </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="nb">id</span>


    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete the instance, first calling the end() method</span>
<span class="sd">        if not already done.          &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># Get value(s) of SD attribute &#39;name&#39;.</span>

        <span class="k">return</span> <span class="n">_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># Set value(s) of SD attribute &#39;name&#39;.</span>

        <span class="c1"># A name starting with an underscore will be treated as</span>
        <span class="c1"># a standard python attribute, and as an HDF attribute</span>
        <span class="c1"># otherwise.</span>

        <span class="n">_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">])</span>

<div class="viewcode-block" id="SD.end"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SD.end">[docs]</a>    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;End access to the SD interface and close the HDF file.</span>

<span class="sd">        Args::</span>

<span class="sd">            no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">            None</span>

<span class="sd">        The instance should not be used afterwards.</span>
<span class="sd">        The &#39;end()&#39; method is implicitly called when the</span>
<span class="sd">        SD instance is deleted.</span>

<span class="sd">        C library equivalent : SDend</span>
<span class="sd">                                                      &quot;&quot;&quot;</span>

        <span class="n">status</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s2">&quot;cannot execute&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="SD.info"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SD.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve information about the SD interface.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          2-element tuple holding:</span>
<span class="sd">            number of datasets inside the file</span>
<span class="sd">            number of file attributes</span>

<span class="sd">        C library equivalent : SDfileinfo</span>
<span class="sd">                                                  &quot;&quot;&quot;</span>

        <span class="n">status</span><span class="p">,</span> <span class="n">n_datasets</span><span class="p">,</span> <span class="n">n_file_attrs</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDfileinfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s2">&quot;cannot execute&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n_datasets</span><span class="p">,</span> <span class="n">n_file_attrs</span></div>

<div class="viewcode-block" id="SD.nametoindex"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SD.nametoindex">[docs]</a>    <span class="k">def</span> <span class="nf">nametoindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sds_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the index number of a dataset given the dataset name.</span>

<span class="sd">        Args::</span>

<span class="sd">          sds_name  : dataset name</span>

<span class="sd">        Returns::</span>

<span class="sd">          index number of the dataset</span>

<span class="sd">        C library equivalent : SDnametoindex</span>
<span class="sd">                                                 &quot;&quot;&quot;</span>

        <span class="n">sds_idx</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDnametoindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">sds_name</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;nametoindex&#39;</span><span class="p">,</span> <span class="n">sds_idx</span><span class="p">,</span> <span class="s1">&#39;non existent SDS&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sds_idx</span></div>

<div class="viewcode-block" id="SD.reftoindex"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SD.reftoindex">[docs]</a>    <span class="k">def</span> <span class="nf">reftoindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sds_ref</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the index number of a dataset given the dataset</span>
<span class="sd">        reference number.</span>

<span class="sd">        Args::</span>

<span class="sd">          sds_ref : dataset reference number</span>

<span class="sd">        Returns::</span>

<span class="sd">          dataset index number</span>

<span class="sd">        C library equivalent : SDreftoindex</span>
<span class="sd">                                             &quot;&quot;&quot;</span>

        <span class="n">sds_idx</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDreftoindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">sds_ref</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;reftoindex&#39;</span><span class="p">,</span> <span class="n">sds_idx</span><span class="p">,</span> <span class="s1">&#39;illegal SDS ref number&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sds_idx</span></div>

<div class="viewcode-block" id="SD.setfillmode"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SD.setfillmode">[docs]</a>    <span class="k">def</span> <span class="nf">setfillmode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_mode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the fill mode for all the datasets in the file.</span>

<span class="sd">        Args::</span>

<span class="sd">          fill_mode : fill mode; one of :</span>
<span class="sd">                        SDC.FILL   write the fill value to all the datasets</span>
<span class="sd">                                  of the file by default</span>
<span class="sd">                        SDC.NOFILL do not write fill values to all datasets</span>
<span class="sd">                                  of the file by default</span>

<span class="sd">        Returns::</span>

<span class="sd">          previous fill mode value</span>

<span class="sd">        C library equivalent: SDsetfillmode</span>
<span class="sd">                                                            &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fill_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SDC</span><span class="o">.</span><span class="n">FILL</span><span class="p">,</span> <span class="n">SDC</span><span class="o">.</span><span class="n">NOFILL</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;bad fill mode&quot;</span><span class="p">)</span>
        <span class="n">old_mode</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDsetfillmode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">fill_mode</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;setfillmode&#39;</span><span class="p">,</span> <span class="n">old_mode</span><span class="p">,</span> <span class="s1">&#39;cannot execute&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">old_mode</span></div>

<div class="viewcode-block" id="SD.create"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SD.create">[docs]</a>    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a dataset.</span>

<span class="sd">        Args::</span>

<span class="sd">          name           dataset name</span>
<span class="sd">          data_type      type of the data, set to one of the SDC.xxx</span>
<span class="sd">                         constants;</span>
<span class="sd">          dim_sizes      lengths of the dataset dimensions; a one-</span>
<span class="sd">                         dimensional array is specified with an integer,</span>
<span class="sd">                         an n-dimensional array with an n-element sequence</span>
<span class="sd">                         of integers; the length of the first dimension can</span>
<span class="sd">                         be set to SDC.UNLIMITED to create an unlimited</span>
<span class="sd">                         dimension (a &quot;record&quot; variable).</span>

<span class="sd">                         IMPORTANT:  netCDF and HDF differ in the way</span>
<span class="sd">                         the UNLIMITED dimension is handled. In netCDF,</span>
<span class="sd">                         all variables of a dataset with an unlimited</span>
<span class="sd">                         dimension grow in sync, eg adding a record to</span>
<span class="sd">                         a variable will implicitly extend other record</span>
<span class="sd">                         variables. In HDF, each record variable grows</span>
<span class="sd">                         independently of each other.</span>

<span class="sd">        Returns::</span>

<span class="sd">          SDS instance for the dataset</span>

<span class="sd">        C library equivalent : SDcreate</span>

<span class="sd">                                                                    &quot;&quot;&quot;</span>

        <span class="c1"># Validate args.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim_sizes</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>  <span class="c1"># allow k instead of [k]</span>
                                        <span class="c1"># for a 1-dim arr</span>
            <span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim_sizes</span><span class="p">]</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim_sizes</span><span class="p">)</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int32</span><span class="p">(</span><span class="n">rank</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rank</span><span class="p">):</span>
            <span class="n">buf</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim_sizes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDcreate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;CREATE&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="s2">&quot;cannot execute&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SDS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span></div>

<div class="viewcode-block" id="SD.select"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SD.select">[docs]</a>    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Locate a dataset.</span>

<span class="sd">        Args::</span>

<span class="sd">          name_or_index  dataset name or index number</span>

<span class="sd">        Returns::</span>

<span class="sd">          SDS instance for the dataset</span>

<span class="sd">        C library equivalent : SDselect</span>
<span class="sd">                                                                    &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_index</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">name_or_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nametoindex</span><span class="p">(</span><span class="n">name_or_index</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">HDF4Error</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;select: non-existent dataset&quot;</span><span class="p">)</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDselect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;select&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="s2">&quot;cannot execute&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SDS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span></div>

<div class="viewcode-block" id="SD.attr"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SD.attr">[docs]</a>    <span class="k">def</span> <span class="nf">attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an SDAttr instance representing a global</span>
<span class="sd">        attribute (defined at the level of the SD interface).</span>

<span class="sd">        Args::</span>

<span class="sd">          name_or_index   attribute name or index number; if a name is</span>
<span class="sd">                          given, the attribute may not exist; in that</span>
<span class="sd">                          case, it will be created when the SDAttr</span>
<span class="sd">                          instance set() method is called</span>

<span class="sd">        Returns::</span>

<span class="sd">          SDAttr instance for the attribute. Call the methods of this</span>
<span class="sd">          class to query, read or set the attribute.</span>

<span class="sd">        C library equivalent : no equivalent</span>

<span class="sd">                                &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">SDAttr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_index</span><span class="p">)</span></div>


<div class="viewcode-block" id="SD.attributes"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SD.attributes">[docs]</a>    <span class="k">def</span> <span class="nf">attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionnary describing every global</span>
<span class="sd">        attribute attached to the SD interface.</span>

<span class="sd">        Args::</span>

<span class="sd">          full      true to get complete info about each attribute</span>
<span class="sd">                    false to report only each attribute value</span>

<span class="sd">        Returns::</span>

<span class="sd">          Empty dictionnary if no global attribute defined</span>
<span class="sd">          Otherwise, dictionnary where each key is the name of a</span>
<span class="sd">          global attribute. If parameter &#39;full&#39; is false,</span>
<span class="sd">          key value is the attribute value. If &#39;full&#39; is true,</span>
<span class="sd">          key value is a tuple with the following elements:</span>

<span class="sd">          - attribute value</span>
<span class="sd">          - attribute index number</span>
<span class="sd">          - attribute type</span>
<span class="sd">          - attribute length</span>

<span class="sd">        C library equivalent : no equivalent</span>
<span class="sd">                                                    &quot;&quot;&quot;</span>

        <span class="c1"># Get the number of global attributes.</span>
        <span class="n">nsds</span><span class="p">,</span> <span class="n">natts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>

        <span class="c1"># Inquire each attribute</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">natts</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">aType</span><span class="p">,</span> <span class="n">nVal</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">(),</span> <span class="n">aType</span><span class="p">,</span> <span class="n">nVal</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="SD.datasets"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SD.datasets">[docs]</a>    <span class="k">def</span> <span class="nf">datasets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionnary describing all the file datasets.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          Empty dictionnary if no dataset is defined.</span>
<span class="sd">          Otherwise, dictionnary whose keys are the file dataset names,</span>
<span class="sd">          and values are tuples describing the corresponding datasets.</span>
<span class="sd">          Each tuple holds the following elements in order:</span>

<span class="sd">          - tuple holding the names of the dimensions defining the</span>
<span class="sd">            dataset coordinate axes</span>
<span class="sd">          - tuple holding the dataset shape (dimension lengths);</span>
<span class="sd">            if a dimension is unlimited, the reported length corresponds</span>
<span class="sd">            to the dimension current length</span>
<span class="sd">          - dataset type</span>
<span class="sd">          - dataset index number</span>

<span class="sd">        C library equivalent : no equivalent</span>
<span class="sd">                                                &quot;&quot;&quot;</span>
        <span class="c1"># Get number of datasets</span>
        <span class="n">nDs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Inquire each var</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nDs</span><span class="p">):</span>
            <span class="c1"># Get dataset info.</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">vName</span><span class="p">,</span> <span class="n">vRank</span><span class="p">,</span> <span class="n">vLen</span><span class="p">,</span> <span class="n">vType</span><span class="p">,</span> <span class="n">vAtt</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">vRank</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>     <span class="c1"># need a sequence</span>
                <span class="n">vLen</span> <span class="o">=</span> <span class="p">[</span><span class="n">vLen</span><span class="p">]</span>
            <span class="c1"># Get dimension info.</span>
            <span class="n">dimNames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">dimLengths</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">dimNum</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vRank</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">dim</span><span class="p">(</span><span class="n">dimNum</span><span class="p">)</span>
                <span class="n">dimNames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">info</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">dimLengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vLen</span><span class="p">[</span><span class="n">dimNum</span><span class="p">])</span>
            <span class="n">res</span><span class="p">[</span><span class="n">vName</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">dimNames</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dimLengths</span><span class="p">),</span>
                         <span class="n">vType</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div></div>


<div class="viewcode-block" id="SDS"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS">[docs]</a><span class="k">class</span> <span class="nc">SDS</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The SDS class implements an HDF dataset object.</span>
<span class="sd">    To create an SDS instance, call the create() or select()</span>
<span class="sd">    methods of the SD class. To set attributes on an SDS instance,</span>
<span class="sd">    call the SDS.attr() method to create an attribute instance,</span>
<span class="sd">    then call the methods of this instance. Attributes can also be</span>
<span class="sd">    set using the &quot;dot notation&quot;. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This constructor should not be called by the user program.</span>
<span class="sd">        Call the SD.create() and SD.select() methods instead.</span>
<span class="sd">                                                  &quot;&quot;&quot;</span>

        <span class="c1"># Args</span>
        <span class="c1">#  sd   : SD instance</span>
        <span class="c1">#  id   : SDS identifier</span>


        <span class="c1"># Private attributes</span>
        <span class="c1">#  _sd  SD intance</span>
        <span class="c1">#  _id  SDS identifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sd</span> <span class="o">=</span> <span class="n">sd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="nb">id</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># Delete the instance, first calling the endaccess() method</span>
        <span class="c1"># if not already done.</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">endaccess</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># Get value(s) of SDS attribute &#39;name&#39;.</span>

        <span class="k">return</span> <span class="n">_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># Set value(s) of SDS attribute &#39;name&#39;.</span>

        <span class="n">_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;_sd&#39;</span><span class="p">,</span> <span class="s1">&#39;_id&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>    <span class="c1"># Needed for slices like &quot;-2:&quot; but why ?</span>

        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">):</span>

        <span class="c1"># This special method is used to index the SDS dataset</span>
        <span class="c1"># using the &quot;extended slice syntax&quot;. The extended slice syntax</span>
        <span class="c1"># is a perfect match for the &quot;start&quot;, &quot;count&quot; and &quot;stride&quot;</span>
        <span class="c1"># arguments to the SDreaddara() function, and is much more easy</span>
        <span class="c1"># to use.</span>

        <span class="c1"># Compute arguments to &#39;SDreaddata_0()&#39;.</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">stride</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__buildStartCountStride</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="c1"># Get elements.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">stride</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

        <span class="c1"># This special method is used to assign to the SDS dataset</span>
        <span class="c1"># using &quot;extended slice syntax&quot;. The extended slice syntax</span>
        <span class="c1"># is a perfect match for the &quot;start&quot;, &quot;count&quot; and &quot;stride&quot;</span>
        <span class="c1"># arguments to the SDwritedata() function, and is much more easy</span>
        <span class="c1"># to use.</span>

        <span class="c1"># Compute arguments to &#39;SDwritedata_0()&#39;.</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">stride</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__buildStartCountStride</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="c1"># A sequence type is needed. Convert a single number to a list.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>
        <span class="c1"># Assign.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">stride</span><span class="p">)</span>

<div class="viewcode-block" id="SDS.endaccess"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.endaccess">[docs]</a>    <span class="k">def</span> <span class="nf">endaccess</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Terminates access to the SDS.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          None.</span>

<span class="sd">        The SDS instance should not be used afterwards.</span>
<span class="sd">        The &#39;endaccess()&#39; method is implicitly called when</span>
<span class="sd">        the SDS instance is deleted.</span>

<span class="sd">        C library equivalent : SDendaccess</span>
<span class="sd">                                                 &quot;&quot;&quot;</span>

        <span class="n">status</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDendaccess</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;endaccess&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s2">&quot;cannot execute&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="kc">None</span>    <span class="c1"># Invalidate identifier</span></div>


<div class="viewcode-block" id="SDS.dim"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.dim">[docs]</a>    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an SDim instance given a dimension index number.</span>

<span class="sd">        Args::</span>

<span class="sd">          dim_index index number of the dimension (numbering starts at 0)</span>

<span class="sd">        C library equivalent : SDgetdimid</span>
<span class="sd">                                                    &quot;&quot;&quot;</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDgetdimid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">dim_index</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;dim&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="s1">&#39;invalid SDS identifier or dimension index&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SDim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">dim_index</span><span class="p">)</span></div>

<div class="viewcode-block" id="SDS.get"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read data from the dataset.</span>

<span class="sd">        Args::</span>

<span class="sd">          start   : indices where to start reading in the data array;</span>
<span class="sd">                    default to 0 on all dimensions</span>
<span class="sd">          count   : number of values to read along each dimension;</span>
<span class="sd">                    default to the current length of all dimensions</span>
<span class="sd">          stride  : sampling interval along each dimension;</span>
<span class="sd">                    default to 1 on all dimensions</span>

<span class="sd">          For n-dimensional datasets, those 3 parameters are entered</span>
<span class="sd">          using lists. For one-dimensional datasets, integers</span>
<span class="sd">          can also be used.</span>

<span class="sd">          Note that, to read the whole dataset contents, one should</span>
<span class="sd">          simply call the method with no argument.</span>

<span class="sd">        Returns::</span>

<span class="sd">          numpy array initialized with the data.</span>

<span class="sd">        C library equivalent : SDreaddata</span>

<span class="sd">        The dataset can also be read using the familiar indexing and</span>
<span class="sd">        slicing notation, like ordinary python sequences.</span>
<span class="sd">        See &quot;High level variable access&quot;.</span>

<span class="sd">                                                       &quot;&quot;&quot;</span>

        <span class="c1"># Obtain SDS info.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sds_name</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">n_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim_sizes</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
                <span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim_sizes</span><span class="p">]</span>
        <span class="k">except</span> <span class="n">HDF4Error</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s1">&#39;get : cannot execute&#39;</span><span class="p">)</span>

        <span class="c1"># Validate args.</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">rank</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">dim_sizes</span>
            <span class="k">if</span> <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
            <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">stride</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stride</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">rank</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stride</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
            <span class="n">stride</span> <span class="o">=</span> <span class="p">[</span><span class="n">stride</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rank</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rank</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">stride</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rank</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s1">&#39;get : start, stride or count &#39;</span> \
                             <span class="s1">&#39;do not match SDS rank&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rank</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">start</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">start</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> \
                  <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">count</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">stride</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">dim_sizes</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s1">&#39;get arguments violate &#39;</span> \
                                 <span class="s1">&#39;the size (</span><span class="si">%d</span><span class="s1">) of dimension </span><span class="si">%d</span><span class="s1">&#39;</span> \
                                 <span class="o">%</span> <span class="p">(</span><span class="n">dim_sizes</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">n</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data_type</span> <span class="ow">in</span> <span class="n">SDC</span><span class="o">.</span><span class="n">equivNumericTypes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s1">&#39;get cannot currrently deal with &#39;</span>\
                             <span class="s1">&#39;the SDS data type&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_C</span><span class="o">.</span><span class="n">_SDreaddata_0</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">stride</span><span class="p">)</span></div>

<div class="viewcode-block" id="SDS.set"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write data to the dataset.</span>

<span class="sd">        Args::</span>

<span class="sd">          data    : array of data to write; can be given as a numpy</span>
<span class="sd">                    array, or as Python sequence (whose elements can be</span>
<span class="sd">                    imbricated sequences)</span>
<span class="sd">          start   : indices where to start writing in the dataset;</span>
<span class="sd">                    default to 0 on all dimensions</span>
<span class="sd">          count   : number of values to write along each dimension;</span>
<span class="sd">                    default to the current length of dataset dimensions</span>
<span class="sd">          stride  : sampling interval along each dimension;</span>
<span class="sd">                    default to 1 on all dimensions</span>

<span class="sd">          For n-dimensional datasets, those 3 parameters are entered</span>
<span class="sd">          using lists. For one-dimensional datasets, integers</span>
<span class="sd">          can also be used.</span>

<span class="sd">          Note that, to write the whole dataset at once, one has simply</span>
<span class="sd">          to call the method with the dataset values in parameter</span>
<span class="sd">          &#39;data&#39;, omitting all other parameters.</span>

<span class="sd">        Returns::</span>

<span class="sd">          None.</span>

<span class="sd">        C library equivalent : SDwritedata</span>

<span class="sd">        The dataset can also be written using the familiar indexing and</span>
<span class="sd">        slicing notation, like ordinary python sequences.</span>
<span class="sd">        See &quot;High level variable access&quot;.</span>

<span class="sd">                                              &quot;&quot;&quot;</span>


        <span class="c1"># Obtain SDS info.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sds_name</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">n_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim_sizes</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
                <span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim_sizes</span><span class="p">]</span>
        <span class="k">except</span> <span class="n">HDF4Error</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s1">&#39;set : cannot execute&#39;</span><span class="p">)</span>

        <span class="c1"># Validate args.</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">rank</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">dim_sizes</span>
            <span class="k">if</span> <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
            <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">stride</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stride</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">rank</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stride</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
            <span class="n">stride</span> <span class="o">=</span> <span class="p">[</span><span class="n">stride</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rank</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rank</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">stride</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rank</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s1">&#39;set : start, stride or count &#39;</span>\
                             <span class="s1">&#39;do not match SDS rank&#39;</span><span class="p">)</span>
        <span class="n">unlimited</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isrecord</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rank</span><span class="p">):</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">start</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ok</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">unlimited</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">start</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">count</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">stride</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">dim_sizes</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                    <span class="n">ok</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s1">&#39;set arguments violate &#39;</span>\
                                 <span class="s1">&#39;the size (</span><span class="si">%d</span><span class="s1">) of dimension </span><span class="si">%d</span><span class="s1">&#39;</span> \
                                 <span class="o">%</span> <span class="p">(</span><span class="n">dim_sizes</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">n</span><span class="p">))</span>
        <span class="c1"># ??? Check support for UINT16</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data_type</span> <span class="ow">in</span> <span class="n">SDC</span><span class="o">.</span><span class="n">equivNumericTypes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s1">&#39;set cannot currrently deal &#39;</span>\
                             <span class="s1">&#39;with the SDS data type&#39;</span><span class="p">)</span>

        <span class="n">_C</span><span class="o">.</span><span class="n">_SDwritedata_0</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">stride</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__buildStartCountStride</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">):</span>

        <span class="c1"># Create the &#39;start&#39;, &#39;count&#39;, &#39;slice&#39; and &#39;stride&#39; tuples that</span>
        <span class="c1"># will be passed to &#39;_SDreaddata_0&#39;/&#39;_SDwritedata_0&#39;.</span>
        <span class="c1">#   start     starting indices along each dimension</span>
        <span class="c1">#   count     count of values along each dimension; a value of -1</span>
        <span class="c1">#             indicates that and index, not a slice, was applied to</span>
        <span class="c1">#             the dimension; in that case, the dimension should be</span>
        <span class="c1">#             dropped from the output array.</span>
        <span class="c1">#   stride    strides along each dimension</span>


        <span class="c1"># Make sure the indexing expression does not exceed the variable</span>
        <span class="c1"># number of dimensions.</span>
        <span class="n">dsName</span><span class="p">,</span> <span class="n">nDims</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dsType</span><span class="p">,</span> <span class="n">nAttr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nDims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;get&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                               <span class="s2">&quot;indexing expression exceeds variable &quot;</span>
                               <span class="s2">&quot;number of dimensions&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>   <span class="c1"># Convert single index to sequence</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">shape</span><span class="p">]</span>

        <span class="n">start</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stride</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">unlimited</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isrecord</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># See if the dimension is unlimited (always at index 0)</span>
            <span class="n">unlim</span> <span class="o">=</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">unlimited</span>
            <span class="c1"># Simple index</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">isslice</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">:</span>
                    <span class="n">e</span> <span class="o">+=</span> <span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="c1"># Respect standard python list behavior: it is illegal to</span>
                <span class="c1"># specify an out of bound index (except for the</span>
                <span class="c1"># unlimited dimension).</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">unlim</span> <span class="ow">and</span> <span class="n">e</span> <span class="o">&gt;=</span> <span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">]):</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;index out of range&quot;</span><span class="p">)</span>
                <span class="n">beg</span> <span class="o">=</span> <span class="n">e</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">e</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">inc</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1"># Slice index. Respect Python syntax for slice upper bounds,</span>
            <span class="c1"># which are not included in the resulting slice. Also, if the</span>
            <span class="c1"># upper bound exceed the dimension size, truncate it.</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">isslice</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># None or 0 means not specified</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                    <span class="n">beg</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">start</span>
                    <span class="k">if</span> <span class="n">beg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">beg</span> <span class="o">+=</span> <span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">beg</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># None of maxint means not specified</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">stop</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">stop</span> <span class="o">!=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">:</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">stop</span>
                    <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">end</span> <span class="o">+=</span> <span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="c1"># None means not specified</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">step</span><span class="p">:</span>
                    <span class="n">inc</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">step</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inc</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1"># Bug</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bug: unexpected element type to __getitem__&quot;</span><span class="p">)</span>

            <span class="c1"># Clip end index (except if unlimited dimension)</span>
            <span class="c1"># and compute number of elements to get.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">unlim</span> <span class="ow">and</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">isslice</span><span class="p">:</span>
                <span class="n">cnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">beg</span><span class="p">)</span> <span class="o">//</span> <span class="n">inc</span>
                <span class="k">if</span> <span class="n">cnt</span> <span class="o">*</span> <span class="n">inc</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">-</span> <span class="n">beg</span><span class="p">:</span>
                    <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cnt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">start</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beg</span><span class="p">)</span>
            <span class="n">count</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
            <span class="n">stride</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inc</span><span class="p">)</span>

        <span class="c1"># Complete missing dimensions</span>
        <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">nDims</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">start</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">count</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="n">stride</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Done</span>
        <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">stride</span>

<div class="viewcode-block" id="SDS.info"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieves information about the dataset.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          5-element tuple holding:</span>

<span class="sd">          - dataset name</span>
<span class="sd">          - dataset rank (number of dimensions)</span>
<span class="sd">          - dataset shape, that is a list giving the length of each</span>
<span class="sd">            dataset dimension; if the first dimension is unlimited, then</span>
<span class="sd">            the first value of the list gives the current length of the</span>
<span class="sd">            unlimited dimension</span>
<span class="sd">          - data type (one of the SDC.xxx values)</span>
<span class="sd">          - number of attributes defined for the dataset</span>

<span class="sd">        C library equivalent : SDgetinfo</span>
<span class="sd">                                                       &quot;&quot;&quot;</span>

        <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int32</span><span class="p">(</span><span class="n">_C</span><span class="o">.</span><span class="n">H4_MAX_VAR_DIMS</span><span class="p">)</span>
        <span class="n">status</span><span class="p">,</span> <span class="n">sds_name</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">n_attrs</span> <span class="o">=</span> \
                <span class="n">_C</span><span class="o">.</span><span class="n">SDgetinfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s2">&quot;cannot execute&quot;</span><span class="p">)</span>
        <span class="n">dim_sizes</span> <span class="o">=</span> <span class="n">_array_to_ret</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sds_name</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">n_attrs</span></div>

<div class="viewcode-block" id="SDS.checkempty"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.checkempty">[docs]</a>    <span class="k">def</span> <span class="nf">checkempty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine whether the dataset is empty.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          True(1) if dataset is empty, False(0) if not</span>

<span class="sd">        C library equivalent : SDcheckempty</span>
<span class="sd">                                                 &quot;&quot;&quot;</span>

        <span class="n">status</span><span class="p">,</span> <span class="n">emptySDS</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDcheckempty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;checkempty&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;invalid SDS identifier&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">emptySDS</span></div>

<div class="viewcode-block" id="SDS.ref"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.ref">[docs]</a>    <span class="k">def</span> <span class="nf">ref</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the reference number of the dataset.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          dataset reference number</span>

<span class="sd">        C library equivalent : SDidtoref</span>
<span class="sd">                                              &quot;&quot;&quot;</span>

        <span class="n">sds_ref</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDidtoref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;idtoref&#39;</span><span class="p">,</span> <span class="n">sds_ref</span><span class="p">,</span> <span class="s1">&#39;illegal SDS identifier&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sds_ref</span></div>

<div class="viewcode-block" id="SDS.iscoordvar"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.iscoordvar">[docs]</a>    <span class="k">def</span> <span class="nf">iscoordvar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine whether the dataset is a coordinate variable</span>
<span class="sd">        (holds a dimension scale). A coordinate variable is created</span>
<span class="sd">        when a dimension is assigned a set of scale values.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          True(1) if the dataset represents a coordinate variable,</span>
<span class="sd">          False(0) if not</span>

<span class="sd">        C library equivalent : SDiscoordvar</span>
<span class="sd">                                           &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDiscoordvar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>   <span class="c1"># no error status here</span></div>

<div class="viewcode-block" id="SDS.isrecord"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.isrecord">[docs]</a>    <span class="k">def</span> <span class="nf">isrecord</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determines whether the dataset is appendable</span>
<span class="sd">        (contains an unlimited dimension). Note that if true, then</span>
<span class="sd">        the unlimited dimension is always dimension number 0.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          True(1) if the dataset is appendable, False(0) if not.</span>

<span class="sd">        C library equivalent : SDisrecord</span>
<span class="sd">                                        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDisrecord</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>     <span class="c1"># no error status here</span></div>


<div class="viewcode-block" id="SDS.getcal"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.getcal">[docs]</a>    <span class="k">def</span> <span class="nf">getcal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve the SDS calibration coefficients.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          5-element tuple holding:</span>

<span class="sd">          - cal: calibration factor (attribute &#39;scale_factor&#39;)</span>
<span class="sd">          - cal_error : calibration factor error</span>
<span class="sd">                        (attribute &#39;scale_factor_err&#39;)</span>
<span class="sd">          - offset: calibration offset (attribute &#39;add_offset&#39;)</span>
<span class="sd">          - offset_err : offset error (attribute &#39;add_offset_err&#39;)</span>
<span class="sd">          - data_type : type of the data resulting from applying</span>
<span class="sd">                        the calibration formula to the dataset values</span>
<span class="sd">                        (attribute &#39;calibrated_nt&#39;)</span>

<span class="sd">        An exception is raised if no calibration data are defined.</span>

<span class="sd">        Original dataset values &#39;orival&#39; are converted to calibrated</span>
<span class="sd">        values &#39;calval&#39; through the formula::</span>

<span class="sd">           calval = cal * (orival - offset)</span>

<span class="sd">        The calibration coefficients are part of the so-called</span>
<span class="sd">        &quot;standard&quot; SDS attributes. The values inside the tuple returned</span>
<span class="sd">        by &#39;getcal&#39; are those of the following attributes, in order::</span>

<span class="sd">          scale_factor, scale_factor_err, add_offset, add_offset_err,</span>
<span class="sd">          calibrated_nt</span>

<span class="sd">        C library equivalent: SDgetcal()</span>
<span class="sd">                                               &quot;&quot;&quot;</span>

        <span class="n">status</span><span class="p">,</span> <span class="n">cal</span><span class="p">,</span> <span class="n">cal_error</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">offset_err</span><span class="p">,</span> <span class="n">data_type</span> <span class="o">=</span> \
                         <span class="n">_C</span><span class="o">.</span><span class="n">SDgetcal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;getcal&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;no calibration record&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cal</span><span class="p">,</span> <span class="n">cal_error</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">offset_err</span><span class="p">,</span> <span class="n">data_type</span></div>

<div class="viewcode-block" id="SDS.getdatastrs"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.getdatastrs">[docs]</a>    <span class="k">def</span> <span class="nf">getdatastrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve the dataset standard string attributes.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          4-element tuple holding:</span>

<span class="sd">          - dataset label string (attribute &#39;long_name&#39;)</span>
<span class="sd">          - dataset unit (attribute &#39;units&#39;)</span>
<span class="sd">          - dataset output format (attribute &#39;format&#39;)</span>
<span class="sd">          - dataset coordinate system (attribute &#39;coordsys&#39;)</span>

<span class="sd">        The values returned by &#39;getdatastrs&#39; are part of the</span>
<span class="sd">        so-called &quot;standard&quot; SDS attributes.  Those 4 values</span>
<span class="sd">        correspond respectively to the following attributes::</span>

<span class="sd">          long_name, units, format, coordsys .</span>

<span class="sd">        C library equivalent: SDgetdatastrs</span>
<span class="sd">                                                       &quot;&quot;&quot;</span>

        <span class="n">status</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="n">coord_system</span> <span class="o">=</span> \
               <span class="n">_C</span><span class="o">.</span><span class="n">SDgetdatastrs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;getdatastrs&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;cannot execute&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">label</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="n">coord_system</span></div>

<div class="viewcode-block" id="SDS.getfillvalue"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.getfillvalue">[docs]</a>    <span class="k">def</span> <span class="nf">getfillvalue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve the dataset fill value.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          dataset fill value (attribute &#39;_FillValue&#39;)</span>

<span class="sd">        An exception is raised if the fill value is not set.</span>

<span class="sd">        The fill value is part of the so-called &quot;standard&quot; SDS</span>
<span class="sd">        attributes, and corresponds to the following attribute::</span>

<span class="sd">          _FillValue</span>

<span class="sd">        C library equivalent: SDgetfillvalue</span>
<span class="sd">                                                   &quot;&quot;&quot;</span>

        <span class="c1"># Obtain SDS data type.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sds_name</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">n_attrs</span> <span class="o">=</span> \
                                <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">HDF4Error</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s1">&#39;getfillvalue : invalid SDS identifier&#39;</span><span class="p">)</span>
        <span class="n">n_values</span> <span class="o">=</span> <span class="mi">1</span>   <span class="c1"># Fill value stands for 1 value.</span>

        <span class="n">convert</span> <span class="o">=</span> <span class="n">_array_to_ret</span>
        <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">CHAR8</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">convert</span> <span class="o">=</span> <span class="n">_array_to_str</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SDC</span><span class="o">.</span><span class="n">UCHAR8</span><span class="p">,</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT8</span><span class="p">]:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT8</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int8</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT16</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT16</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">FLOAT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">FLOAT64</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float64</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;getfillvalue: SDS has an illegal type or &quot;</span> \
                             <span class="s2">&quot;unsupported type </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">data_type</span><span class="p">)</span>

        <span class="n">status</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDgetfillvalue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;getfillvalue&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;fill value not set&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">convert</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">n_values</span><span class="p">)</span></div>

<div class="viewcode-block" id="SDS.getrange"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.getrange">[docs]</a>    <span class="k">def</span> <span class="nf">getrange</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve the dataset min and max values.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          (min, max) tuple (attribute &#39;valid_range&#39;)</span>

<span class="sd">          Note that those are the values as stored</span>
<span class="sd">          by the &#39;setrange&#39; method. &#39;getrange&#39; does *NOT* compute the</span>
<span class="sd">          min and max from the current dataset contents.</span>

<span class="sd">        An exception is raised if the range is not set.</span>

<span class="sd">        The range returned by &#39;getrange&#39; is part of the so-called</span>
<span class="sd">        &quot;standard&quot; SDS attributes. It corresponds to the following</span>
<span class="sd">        attribute::</span>

<span class="sd">          valid_range</span>

<span class="sd">        C library equivalent: SDgetrange</span>
<span class="sd">                                                       &quot;&quot;&quot;</span>

        <span class="c1"># Obtain SDS data type.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sds_name</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">n_attrs</span> <span class="o">=</span> \
                               <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">HDF4Error</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s1">&#39;getrange : invalid SDS identifier&#39;</span><span class="p">)</span>
        <span class="n">n_values</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">convert</span> <span class="o">=</span> <span class="n">_array_to_ret</span>
        <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">CHAR8</span><span class="p">:</span>
            <span class="n">buf1</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">buf2</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">convert</span> <span class="o">=</span> <span class="n">_array_to_str</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="ow">in</span>  <span class="p">[</span><span class="n">SDC</span><span class="o">.</span><span class="n">UCHAR8</span><span class="p">,</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT8</span><span class="p">]:</span>
            <span class="n">buf1</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">buf2</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT8</span><span class="p">:</span>
            <span class="n">buf1</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int8</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">buf2</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int8</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT16</span><span class="p">:</span>
            <span class="n">buf1</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">buf2</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT16</span><span class="p">:</span>
            <span class="n">buf1</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">buf2</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT32</span><span class="p">:</span>
            <span class="n">buf1</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">buf2</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT32</span><span class="p">:</span>
            <span class="n">buf1</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">buf2</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">FLOAT32</span><span class="p">:</span>
            <span class="n">buf1</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">buf2</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">FLOAT64</span><span class="p">:</span>
            <span class="n">buf1</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float64</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">buf2</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float64</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;getrange: SDS has an illegal or &quot;</span> \
                             <span class="s2">&quot;unsupported type </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">data</span><span class="p">)</span>

        <span class="c1"># Note: The C routine returns the max in buf1 and the min</span>
        <span class="c1"># in buf2. We swap the values returned by the Python</span>
        <span class="c1"># interface, since it is more natural to return</span>
        <span class="c1"># min first, then max.</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDgetrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">buf1</span><span class="p">,</span> <span class="n">buf2</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;getrange&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;range not set&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">convert</span><span class="p">(</span><span class="n">buf2</span><span class="p">,</span> <span class="n">n_values</span><span class="p">),</span> <span class="n">convert</span><span class="p">(</span><span class="n">buf1</span><span class="p">,</span> <span class="n">n_values</span><span class="p">)</span></div>

<div class="viewcode-block" id="SDS.setcal"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.setcal">[docs]</a>    <span class="k">def</span> <span class="nf">setcal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cal</span><span class="p">,</span> <span class="n">cal_error</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">offset_err</span><span class="p">,</span> <span class="n">data_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the dataset calibration coefficients.</span>

<span class="sd">        Args::</span>

<span class="sd">          cal         the calibraton factor (attribute &#39;scale_factor&#39;)</span>
<span class="sd">          cal_error   calibration factor error</span>
<span class="sd">                      (attribute &#39;scale_factor_err&#39;)</span>
<span class="sd">          offset      offset value (attribute &#39;add_offset&#39;)</span>
<span class="sd">          offset_err  offset error (attribute &#39;add_offset_err&#39;)</span>
<span class="sd">          data_type   data type of the values resulting from applying the</span>
<span class="sd">                      calibration formula to the dataset values</span>
<span class="sd">                      (one of the SDC.xxx constants)</span>
<span class="sd">                      (attribute &#39;calibrated_nt&#39;)</span>

<span class="sd">        Returns::</span>

<span class="sd">          None</span>

<span class="sd">        See method &#39;getcal&#39; for the definition of the calibration</span>
<span class="sd">        formula.</span>

<span class="sd">        Calibration coefficients are part of the so-called standard</span>
<span class="sd">        SDS attributes. Calling &#39;setcal&#39; is equivalent to setting</span>
<span class="sd">        the following attributes, which correspond to the method</span>
<span class="sd">        parameters, in order::</span>

<span class="sd">          scale_factor, scale_factor_err, add_offset, add_offset_err,</span>
<span class="sd">          calibrated_nt</span>

<span class="sd">        C library equivalent: SDsetcal</span>
<span class="sd">                                                      &quot;&quot;&quot;</span>

        <span class="n">status</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDsetcal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">cal</span><span class="p">,</span> <span class="n">cal_error</span><span class="p">,</span>
                             <span class="n">offset</span><span class="p">,</span> <span class="n">offset_err</span><span class="p">,</span> <span class="n">data_type</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;setcal&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;cannot execute&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SDS.setdatastrs"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.setdatastrs">[docs]</a>    <span class="k">def</span> <span class="nf">setdatastrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="n">coord_sys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the dataset standard string type attributes.</span>

<span class="sd">        Args::</span>

<span class="sd">          label         dataset label (attribute &#39;long_name&#39;)</span>
<span class="sd">          unit          dataset unit (attribute &#39;units&#39;)</span>
<span class="sd">          format        dataset format (attribute &#39;format&#39;)</span>
<span class="sd">          coord_sys     dataset coordinate system (attribute &#39;coordsys&#39;)</span>

<span class="sd">        Returns::</span>

<span class="sd">          None</span>

<span class="sd">        Those strings are part of the so-called standard</span>
<span class="sd">        SDS attributes. Calling &#39;setdatastrs&#39; is equivalent to setting</span>
<span class="sd">        the following attributes, which correspond to the method</span>
<span class="sd">        parameters, in order::</span>

<span class="sd">          long_name, units, format, coordsys</span>

<span class="sd">        C library equivalent: SDsetdatastrs</span>
<span class="sd">                                                     &quot;&quot;&quot;</span>

        <span class="n">status</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDsetdatastrs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="n">coord_sys</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;setdatastrs&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;cannot execute&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SDS.setfillvalue"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.setfillvalue">[docs]</a>    <span class="k">def</span> <span class="nf">setfillvalue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the dataset fill value.</span>

<span class="sd">        Args::</span>

<span class="sd">          fill_val   dataset fill value (attribute &#39;_FillValue&#39;)</span>

<span class="sd">        Returns::</span>

<span class="sd">          None</span>

<span class="sd">        The fill value is part of the so-called &quot;standard&quot; SDS</span>
<span class="sd">        attributes. Calling &#39;setfillvalue&#39; is equivalent to setting</span>
<span class="sd">        the following attribute::</span>

<span class="sd">          _FillValue</span>

<span class="sd">        C library equivalent: SDsetfillvalue</span>
<span class="sd">                                                           &quot;&quot;&quot;</span>

        <span class="c1"># Obtain SDS data type.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sds_name</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">n_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">HDF4Error</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s1">&#39;setfillvalue : cannot execute&#39;</span><span class="p">)</span>
        <span class="n">n_values</span> <span class="o">=</span> <span class="mi">1</span>   <span class="c1"># Fill value stands for 1 value.</span>

        <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">CHAR8</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SDC</span><span class="o">.</span><span class="n">UCHAR8</span><span class="p">,</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT8</span><span class="p">]:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT8</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int8</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT16</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT16</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">FLOAT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">FLOAT64</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float64</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;setfillvalue: SDS has an illegal or &quot;</span> \
                             <span class="s2">&quot;unsupported type </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">data_type</span><span class="p">)</span>

        <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_val</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDsetfillvalue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;setfillvalue&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;cannot execute&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SDS.setrange"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.setrange">[docs]</a>    <span class="k">def</span> <span class="nf">setrange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the dataset min and max values.</span>

<span class="sd">        Args::</span>

<span class="sd">          min        dataset minimum value (attribute &#39;valid_range&#39;)</span>
<span class="sd">          max        dataset maximum value (attribute &#39;valid_range&#39;)</span>


<span class="sd">        Returns::</span>

<span class="sd">          None</span>

<span class="sd">        The data range is part of the so-called &quot;standard&quot; SDS</span>
<span class="sd">        attributes. Calling method &#39;setrange&#39; is equivalent to</span>
<span class="sd">        setting the following attribute with a 2-element [min,max]</span>
<span class="sd">        array::</span>

<span class="sd">          valid_range</span>


<span class="sd">        C library equivalent: SDsetrange</span>
<span class="sd">                                                   &quot;&quot;&quot;</span>

        <span class="c1"># Obtain SDS data type.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sds_name</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">n_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">HDF4Error</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s1">&#39;setrange : cannot execute&#39;</span><span class="p">)</span>
        <span class="n">n_values</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">CHAR8</span><span class="p">:</span>
            <span class="n">buf1</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">buf2</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SDC</span><span class="o">.</span><span class="n">UCHAR8</span><span class="p">,</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT8</span><span class="p">]:</span>
            <span class="n">buf1</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">buf2</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT8</span><span class="p">:</span>
            <span class="n">buf1</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int8</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">buf2</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int8</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT16</span><span class="p">:</span>
            <span class="n">buf1</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">buf2</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT16</span><span class="p">:</span>
            <span class="n">buf1</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">buf2</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT32</span><span class="p">:</span>
            <span class="n">buf1</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">buf2</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT32</span><span class="p">:</span>
            <span class="n">buf1</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">buf2</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">FLOAT32</span><span class="p">:</span>
            <span class="n">buf1</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">buf2</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">FLOAT64</span><span class="p">:</span>
            <span class="n">buf1</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float64</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="n">buf2</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float64</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;SDsetrange: SDS has an illegal or &quot;</span> \
                             <span class="s2">&quot;unsupported type </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">data_type</span><span class="p">)</span>

        <span class="n">buf1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span>
        <span class="n">buf2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDsetrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">buf1</span><span class="p">,</span> <span class="n">buf2</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;setrange&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;cannot execute&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SDS.getcompress"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.getcompress">[docs]</a>    <span class="k">def</span> <span class="nf">getcompress</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieves info about dataset compression type and mode.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          tuple holding:</span>

<span class="sd">          - compression type (one of the SDC.COMP_xxx constants)</span>
<span class="sd">          - optional values, depending on the compression type</span>
<span class="sd">              COMP_NONE       0 value    no additional value</span>
<span class="sd">              COMP_SKPHUFF    1 value  : skip size</span>
<span class="sd">              COMP_DEFLATE    1 value  : gzip compression level (1 to 9)</span>
<span class="sd">              COMP_SZIP       5 values : options mask,</span>
<span class="sd">                                         pixels per block (2 to 32)</span>
<span class="sd">                                         pixels per scanline,</span>
<span class="sd">                                         bits per pixel (number of bits in the SDS datatype)</span>
<span class="sd">                                         pixels (number of elements in the SDS)</span>

<span class="sd">                                         Note: in the context of an SDS, the word &quot;pixel&quot;</span>
<span class="sd">                                         should really be understood as meaning &quot;data element&quot;,</span>
<span class="sd">                                         eg a cell value inside a multidimensional grid.</span>
<span class="sd">                                         Test the options mask against constants SDC.COMP_SZIP_NN</span>
<span class="sd">                                         and SDC.COMP_SZIP_EC, eg :</span>
<span class="sd">                                           if optionMask &amp; SDC.COMP_SZIP_EC:</span>
<span class="sd">                                               print &quot;EC encoding scheme used&quot;</span>

<span class="sd">        An exception is raised if dataset is not compressed.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Starting with v0.8, an exception is always raised if</span>
<span class="sd">            pyhdf was installed with the NOCOMPRESS macro set.</span>

<span class="sd">        C library equivalent: SDgetcompress</span>
<span class="sd">                                                           &quot;&quot;&quot;</span>

        <span class="n">status</span><span class="p">,</span> <span class="n">comp_type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v4</span><span class="p">,</span> <span class="n">v5</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">_SDgetcompress</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;getcompress&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;no compression&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">comp_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">COMP_NONE</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">comp_type</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="n">comp_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">COMP_SZIP</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">comp_type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v4</span><span class="p">,</span> <span class="n">v5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">comp_type</span><span class="p">,</span> <span class="n">value</span></div>

<div class="viewcode-block" id="SDS.setcompress"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.setcompress">[docs]</a>    <span class="k">def</span> <span class="nf">setcompress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comp_type</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">v2</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compresses the dataset using a specified compression method.</span>

<span class="sd">        Args::</span>

<span class="sd">          comp_type    compression type, identified by one of the</span>
<span class="sd">                       SDC.COMP_xxx constants</span>
<span class="sd">          value,v2     auxiliary value(s) needed by some compression types</span>
<span class="sd">                         SDC.COMP_SKPHUFF   Skipping-Huffman; compression value=data size in bytes, v2 is ignored</span>
<span class="sd">                         SDC.COMP_DEFLATE   Gzip compression; value=deflate level (1 to 9), v2 is ignored</span>
<span class="sd">                         SDC.COMP_SZIP      Szip compression; value=encoding scheme (SDC.COMP_SZIP_EC or</span>
<span class="sd">                                            SDC.COMP_SZIP_NN), v2=pixels per block (2 to 32)</span>

<span class="sd">        Returns::</span>

<span class="sd">            None</span>

<span class="sd">        .. note::</span>
<span class="sd">             Starting with v0.8, an exception is always raised if</span>
<span class="sd">             pyhdf was installed with the NOCOMPRESS macro set.</span>

<span class="sd">        SDC.COMP_DEFLATE applies the GZIP compression to the dataset,</span>
<span class="sd">        and the value varies from 1 to 9, according to the level of</span>
<span class="sd">        compression desired.</span>

<span class="sd">        SDC.COMP_SZIP compresses the dataset using the SZIP algorithm. See the HDF User&#39;s Guide</span>
<span class="sd">        for details about the encoding scheme and the number of pixels per block. SZIP is new</span>
<span class="sd">        with HDF 4.2.</span>

<span class="sd">        &#39;setcompress&#39; must be called before writing to the dataset.</span>
<span class="sd">        The dataset must be written all at once, unless it is</span>
<span class="sd">        appendable (has an unlimited dimension). Updating the dataset</span>
<span class="sd">        in not allowed. Refer to the HDF user&#39;s guide for more details</span>
<span class="sd">        on how to use data compression.</span>

<span class="sd">        C library equivalent: SDsetcompress</span>
<span class="sd">                                                          &quot;&quot;&quot;</span>

        <span class="n">status</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">_SDsetcompress</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">comp_type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;setcompress&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;cannot execute&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SDS.setexternalfile"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.setexternalfile">[docs]</a>    <span class="k">def</span> <span class="nf">setexternalfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store the dataset data in an external file.</span>

<span class="sd">        Args::</span>

<span class="sd">          filename    external file name</span>
<span class="sd">          offset      offset in bytes where to start writing in</span>
<span class="sd">                      the external file</span>

<span class="sd">        Returns::</span>

<span class="sd">            None</span>

<span class="sd">        C library equivalent : SDsetexternalfile</span>
<span class="sd">                                                  &quot;&quot;&quot;</span>

        <span class="n">status</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDsetexternalfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;setexternalfile&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;execution error&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SDS.attr"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.attr">[docs]</a>    <span class="k">def</span> <span class="nf">attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an SDAttr instance representing an SDS</span>
<span class="sd">        (dataset) attribute.</span>

<span class="sd">        Args::</span>

<span class="sd">          name_or_index   attribute name or index number; if a name is</span>
<span class="sd">                          given, the attribute may not exist</span>

<span class="sd">        Returns::</span>

<span class="sd">          SDAttr instance for the attribute. Call the methods of this</span>
<span class="sd">          class to query, read or set the attribute.</span>

<span class="sd">        C library equivalent : no equivalent</span>

<span class="sd">                                &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">SDAttr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_index</span><span class="p">)</span></div>

<div class="viewcode-block" id="SDS.attributes"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.attributes">[docs]</a>    <span class="k">def</span> <span class="nf">attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionnary describing every attribute defined</span>
<span class="sd">        on the dataset.</span>

<span class="sd">        Args::</span>

<span class="sd">          full      true to get complete info about each attribute</span>
<span class="sd">                    false to report only each attribute value</span>

<span class="sd">        Returns::</span>

<span class="sd">          Empty dictionnary if no attribute defined.</span>
<span class="sd">          Otherwise, dictionnary where each key is the name of a</span>
<span class="sd">          dataset attribute. If parameter &#39;full&#39; is false,</span>
<span class="sd">          key value is the attribute value. If &#39;full&#39; is true,</span>
<span class="sd">          key value is a tuple with the following elements:</span>

<span class="sd">          - attribute value</span>
<span class="sd">          - attribute index number</span>
<span class="sd">          - attribute type</span>
<span class="sd">          - attribute length</span>

<span class="sd">        C library equivalent : no equivalent</span>
<span class="sd">                                                    &quot;&quot;&quot;</span>

        <span class="c1"># Get the number of dataset attributes.</span>
        <span class="n">natts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">()[</span><span class="mi">4</span><span class="p">]</span>

        <span class="c1"># Inquire each attribute</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">natts</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">aType</span><span class="p">,</span> <span class="n">nVal</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">(),</span> <span class="n">aType</span><span class="p">,</span> <span class="n">nVal</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="SDS.dimensions"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDS.dimensions">[docs]</a>    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionnary describing every dataset dimension.</span>

<span class="sd">        Args::</span>

<span class="sd">          full      true to get complete info about each dimension</span>
<span class="sd">                    false to report only each dimension length</span>

<span class="sd">        Returns::</span>

<span class="sd">          Dictionnary where each key is a dimension name. If no name</span>
<span class="sd">          has been given to the dimension, the key is set to</span>
<span class="sd">          &#39;fakeDimx&#39; where &#39;x&#39; is the dimension index number.</span>
<span class="sd">          If parameter &#39;full&#39; is false, key value is the dimension</span>
<span class="sd">          length. If &#39;full&#39; is true, key value is a 5-element tuple</span>
<span class="sd">          with the following elements:</span>

<span class="sd">          - dimension length; for an unlimited dimension, the reported</span>
<span class="sd">            length is the current dimension length</span>
<span class="sd">          - dimension index number</span>
<span class="sd">          - 1 if the dimension is unlimited, 0 otherwise</span>
<span class="sd">          - dimension scale type, or 0 if no scale is defined for</span>
<span class="sd">            the dimension</span>
<span class="sd">          - number of attributes defined on the dimension</span>

<span class="sd">        C library equivalent : no equivalent</span>
<span class="sd">                                                    &quot;&quot;&quot;</span>

        <span class="c1"># Get the number of dimensions and their lengths.</span>
        <span class="n">nDims</span><span class="p">,</span> <span class="n">dimLen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">()[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimLen</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>    <span class="c1"># need a sequence</span>
            <span class="n">dimLen</span> <span class="o">=</span> <span class="p">[</span><span class="n">dimLen</span><span class="p">]</span>
        <span class="c1"># Check if the dataset is appendable.</span>
        <span class="n">unlim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isrecord</span><span class="p">()</span>

        <span class="c1"># Inquire each dimension</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nDims</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="c1"># The length reported by info() is 0 for an unlimited dimension.</span>
            <span class="c1"># Rather use the lengths reported by SDS.info()</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">scaleType</span><span class="p">,</span> <span class="n">nAtt</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">dimLen</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">unlim</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                             <span class="n">scaleType</span><span class="p">,</span> <span class="n">nAtt</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">length</span>

        <span class="k">return</span> <span class="n">res</span></div></div>


<div class="viewcode-block" id="SDim"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDim">[docs]</a><span class="k">class</span> <span class="nc">SDim</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The SDim class implements a dimension object.</span>
<span class="sd">       There can be one dimension object for each dataset dimension.</span>
<span class="sd">       To create an SDim instance, call the dim() method of an SDS class</span>
<span class="sd">       instance. To set attributes on an SDim instance, call the</span>
<span class="sd">       SDim.attr() method to create an attribute instance, then call the</span>
<span class="sd">       methods of this instance.  Attributes can also be set using the</span>
<span class="sd">       &quot;dot notation&quot;. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sds</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Init an SDim instance. This method should not be called</span>
<span class="sd">        directly by the user program. To create an SDim instance,</span>
<span class="sd">        call the SDS.dim() method.</span>
<span class="sd">                                                 &quot;&quot;&quot;</span>

        <span class="c1"># Args:</span>
        <span class="c1">#  sds    SDS instance</span>
        <span class="c1">#  id     dimension identifier</span>
        <span class="c1">#  index  index number of the dimension</span>

        <span class="c1"># SDim private attributes</span>
        <span class="c1">#  _sds    sds instance</span>
        <span class="c1">#  _id     dimension identifier</span>
        <span class="c1">#  _index  dimension index number</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sds</span> <span class="o">=</span> <span class="n">sds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">index</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># Get value(s) of SDim attribute &#39;name&#39;.</span>

        <span class="k">return</span> <span class="n">_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># Set value(s) of SDim attribute &#39;name&#39;.</span>

        <span class="n">_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;_sds&#39;</span><span class="p">,</span> <span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;_index&#39;</span><span class="p">])</span>


<div class="viewcode-block" id="SDim.info"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDim.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return info about the dimension instance.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          4-element tuple holding:</span>

<span class="sd">          - dimension name; &#39;fakeDimx&#39; is returned if the dimension</span>
<span class="sd">            has not been named yet, where &#39;x&#39; is the dimension</span>
<span class="sd">            index number</span>
<span class="sd">          - dimension length; 0 is returned if the dimension is unlimited;</span>
<span class="sd">            call the SDim.length() or SDS.info() methods to obtain the</span>
<span class="sd">            current dimension length</span>
<span class="sd">          - scale data type (one of the SDC.xxx constants); 0 is</span>
<span class="sd">            returned if no scale has been set on the dimension</span>
<span class="sd">          - number of attributes attached to the dimension</span>

<span class="sd">        C library equivalent : SDdiminfo</span>
<span class="sd">                                                    &quot;&quot;&quot;</span>
        <span class="n">status</span><span class="p">,</span> <span class="n">dim_name</span><span class="p">,</span> <span class="n">dim_size</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">n_attrs</span> <span class="o">=</span> \
                <span class="n">_C</span><span class="o">.</span><span class="n">SDdiminfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;cannot execute&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dim_name</span><span class="p">,</span> <span class="n">dim_size</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">n_attrs</span></div>

<div class="viewcode-block" id="SDim.length"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDim.length">[docs]</a>    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the dimension length. This method is usefull</span>
<span class="sd">        to quickly retrieve the current length of an unlimited</span>
<span class="sd">        dimension.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          dimension length; if the dimension is unlimited, the</span>
<span class="sd">          returned value is the current dimension length</span>

<span class="sd">        C library equivalent : no equivalent</span>
<span class="sd">                                                   &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sds</span><span class="o">.</span><span class="n">info</span><span class="p">()[</span><span class="mi">2</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">]</span></div>

<div class="viewcode-block" id="SDim.setname"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDim.setname">[docs]</a>    <span class="k">def</span> <span class="nf">setname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the dimension name.</span>

<span class="sd">        Args::</span>

<span class="sd">          dim_name    dimension name; setting 2 dimensions to the same</span>
<span class="sd">                      name make the dimensions &quot;shared&quot;; in order to be</span>
<span class="sd">                      shared, the dimesions must be deined similarly.</span>

<span class="sd">        Returns::</span>

<span class="sd">          None</span>

<span class="sd">        C library equivalent : SDsetdimname</span>
<span class="sd">                                                            &quot;&quot;&quot;</span>

        <span class="n">status</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDsetdimname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">dim_name</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;setname&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;cannot execute&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SDim.getscale"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDim.getscale">[docs]</a>    <span class="k">def</span> <span class="nf">getscale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Obtain the scale values along a dimension.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          list with the scale values; the list length is equal to the</span>
<span class="sd">          dimension length; the element type is equal to the dimension</span>
<span class="sd">          data type, as set when the &#39;setdimscale()&#39; method was called.</span>

<span class="sd">        C library equivalent : SDgetdimscale</span>
<span class="sd">                                                  &quot;&quot;&quot;</span>

        <span class="c1"># Get dimension info. If data_type is 0, no scale have been set</span>
        <span class="c1"># on the dimension.</span>
        <span class="n">status</span><span class="p">,</span> <span class="n">dim_name</span><span class="p">,</span> <span class="n">dim_size</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">n_attrs</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDdiminfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;getscale&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;cannot execute&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;no scale set on that dimension&quot;</span><span class="p">)</span>

        <span class="c1"># dim_size is 0 for an unlimited dimension. The actual length is</span>
        <span class="c1"># obtained through SDgetinfo.</span>
        <span class="k">if</span> <span class="n">dim_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dim_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sds</span><span class="o">.</span><span class="n">info</span><span class="p">()[</span><span class="mi">2</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">]</span>

        <span class="c1"># Get scale values.</span>
        <span class="k">if</span> <span class="n">data_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SDC</span><span class="o">.</span><span class="n">UCHAR8</span><span class="p">,</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT8</span><span class="p">]:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">dim_size</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT8</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int8</span><span class="p">(</span><span class="n">dim_size</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT16</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int16</span><span class="p">(</span><span class="n">dim_size</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT16</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint16</span><span class="p">(</span><span class="n">dim_size</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int32</span><span class="p">(</span><span class="n">dim_size</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint32</span><span class="p">(</span><span class="n">dim_size</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">FLOAT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float32</span><span class="p">(</span><span class="n">dim_size</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">FLOAT64</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float64</span><span class="p">(</span><span class="n">dim_size</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;getscale: dimension has an &quot;</span>\
                             <span class="s2">&quot;illegal or unsupported type </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">data_type</span><span class="p">)</span>

        <span class="n">status</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDgetdimscale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;getscale&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;cannot execute&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_array_to_ret</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">dim_size</span><span class="p">)</span></div>

<div class="viewcode-block" id="SDim.setscale"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDim.setscale">[docs]</a>    <span class="k">def</span> <span class="nf">setscale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the scale values along the dimension.</span>

<span class="sd">        Args::</span>

<span class="sd">          data_type    data type code (one of the SDC.xxx constants)</span>
<span class="sd">          scale        sequence holding the scale values; the number of</span>
<span class="sd">                       values must match the current length of the dataset</span>
<span class="sd">                       along that dimension</span>

<span class="sd">        C library equivalent : SDsetdimscale</span>

<span class="sd">        Setting a scale on a dimension generates what HDF calls a</span>
<span class="sd">        &quot;coordinate variable&quot;. This is a rank 1 dataset similar to any</span>
<span class="sd">        other dataset, which is created to hold the scale values. The</span>
<span class="sd">        dataset name is identical to that of the dimension on which</span>
<span class="sd">        setscale() is called, and the data type passed in &#39;data_type&#39;</span>
<span class="sd">        determines the type of the dataset. To distinguish between such</span>
<span class="sd">        a dataset and a &quot;normal&quot; dataset, call the iscoordvar() method</span>
<span class="sd">        of the dataset instance.</span>
<span class="sd">                                                         &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">n_values</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">n_values</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Validate args</span>
        <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sds</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dim_size</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dim_size</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n_values</span> <span class="o">!=</span> <span class="n">dim_size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s1">&#39;number of scale values (</span><span class="si">%d</span><span class="s1">) does not match &#39;</span> \
                             <span class="s1">&#39;dimension size (</span><span class="si">%d</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_values</span><span class="p">,</span> <span class="n">dim_size</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">CHAR8</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>
            <span class="c1"># Allow a string as the scale argument.</span>
            <span class="c1"># Becomes a noop if already a list.</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_values</span><span class="p">):</span>
                <span class="n">scale</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">scale</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SDC</span><span class="o">.</span><span class="n">UCHAR8</span><span class="p">,</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT8</span><span class="p">]:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_byte</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT8</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int8</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT16</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT16</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint16</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_int32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">UINT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_uint32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">FLOAT32</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float32</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">SDC</span><span class="o">.</span><span class="n">FLOAT64</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">array_float64</span><span class="p">(</span><span class="n">n_values</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;setscale: illegal or usupported data_type&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n_values</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_values</span><span class="p">):</span>
                <span class="n">buf</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDsetdimscale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">n_values</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;setscale&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;cannot execute&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SDim.getstrs"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDim.getstrs">[docs]</a>    <span class="k">def</span> <span class="nf">getstrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve the dimension standard string attributes.</span>

<span class="sd">        Args::</span>

<span class="sd">          no argument</span>

<span class="sd">        Returns::</span>

<span class="sd">          3-element tuple holding:</span>
<span class="sd">            -dimension label  (attribute &#39;long_name&#39;)</span>
<span class="sd">            -dimension unit   (attribute &#39;units&#39;)</span>
<span class="sd">            -dimension format (attribute &#39;format&#39;)</span>

<span class="sd">        An exception is raised if the standard attributes have</span>
<span class="sd">        not been set.</span>

<span class="sd">        C library equivalent: SDgetdimstrs</span>
<span class="sd">                                                &quot;&quot;&quot;</span>

        <span class="n">status</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="nb">format</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDgetdimstrs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;getstrs&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;cannot execute&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">label</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="nb">format</span></div>

<div class="viewcode-block" id="SDim.setstrs"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDim.setstrs">[docs]</a>    <span class="k">def</span> <span class="nf">setstrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="nb">format</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the dimension standard string attributes.</span>

<span class="sd">        Args::</span>

<span class="sd">          label   dimension label  (attribute &#39;long_name&#39;)</span>
<span class="sd">          unit    dimension unit   (attribute &#39;units&#39;)</span>
<span class="sd">          format  dimension format (attribute &#39;format&#39;)</span>

<span class="sd">        Returns::</span>

<span class="sd">          None</span>

<span class="sd">        C library equivalent: SDsetdimstrs</span>
<span class="sd">                                                     &quot;&quot;&quot;</span>

        <span class="n">status</span> <span class="o">=</span> <span class="n">_C</span><span class="o">.</span><span class="n">SDsetdimstrs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="nb">format</span><span class="p">)</span>
        <span class="n">_checkErr</span><span class="p">(</span><span class="s1">&#39;setstrs&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s1">&#39;cannot execute&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SDim.attr"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDim.attr">[docs]</a>    <span class="k">def</span> <span class="nf">attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an SDAttr instance representing an SDim</span>
<span class="sd">        (dimension) attribute.</span>

<span class="sd">        Args::</span>

<span class="sd">          name_or_index   attribute name or index number; if a name is</span>
<span class="sd">                          given, the attribute may not exist; in that</span>
<span class="sd">                          case, the attribute is created when the</span>
<span class="sd">                          instance set() method is called</span>

<span class="sd">        Returns::</span>

<span class="sd">          SDAttr instance for the attribute. Call the methods of this</span>
<span class="sd">          class to query, read or set the attribute.</span>

<span class="sd">        C library equivalent : no equivalent</span>

<span class="sd">                                &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">SDAttr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_index</span><span class="p">)</span></div>

<div class="viewcode-block" id="SDim.attributes"><a class="viewcode-back" href="../../modules/SD.html#pyhdf.SD.SDim.attributes">[docs]</a>    <span class="k">def</span> <span class="nf">attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionnary describing every attribute defined</span>
<span class="sd">        on the dimension.</span>

<span class="sd">        Args::</span>

<span class="sd">          full      true to get complete info about each attribute</span>
<span class="sd">                    false to report only each attribute value</span>

<span class="sd">        Returns::</span>

<span class="sd">          Empty dictionnary if no attribute defined.</span>
<span class="sd">          Otherwise, dictionnary where each key is the name of a</span>
<span class="sd">          dimension attribute. If parameter &#39;full&#39; is false,</span>
<span class="sd">          key value is the attribute value. If &#39;full&#39; is true,</span>
<span class="sd">          key value is a tuple with the following elements:</span>

<span class="sd">          - attribute value</span>
<span class="sd">          - attribute index number</span>
<span class="sd">          - attribute type</span>
<span class="sd">          - attribute length</span>

<span class="sd">        C library equivalent : no equivalent</span>
<span class="sd">                                                    &quot;&quot;&quot;</span>

        <span class="c1"># Get the number of dataset attributes.</span>
        <span class="n">natts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">()[</span><span class="mi">3</span><span class="p">]</span>

        <span class="c1"># Inquire each attribute</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">natts</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">aType</span><span class="p">,</span> <span class="n">nVal</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">(),</span> <span class="n">aType</span><span class="p">,</span> <span class="n">nVal</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">res</span></div></div>



<span class="c1">###########################</span>
<span class="c1"># Support functions</span>
<span class="c1">###########################</span>

<span class="k">def</span> <span class="nf">_getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="c1"># Called by the __getattr__ method of the SD, SDS and SDim objects.</span>

    <span class="c1"># Python will call __getattr__ to see if the class wants to</span>
    <span class="c1"># define certain missing methods (__str__, __len__, etc).</span>
    <span class="c1"># Always fail if the name starts with two underscores.</span>
    <span class="k">if</span> <span class="n">name</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;__&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span>
    <span class="c1"># See if we deal with an SD attribute.</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">SDAttr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">HDF4Error</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;attribute not found&quot;</span><span class="p">)</span>
    <span class="c1"># Return attribute value(s).</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">privAttr</span><span class="p">):</span>
    <span class="c1"># Called by the __setattr__ method of the SD, SDS and SDim objects.</span>

    <span class="c1"># Be careful with private attributes.</span>
    <span class="c1">#if name in privAttr:</span>
    <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;_&#39;</span><span class="p">:</span>
        <span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span>

    <span class="c1"># Treat everything else as an HDF attribute.</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
    <span class="n">typeList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="c1"># Prohibit mixing numeric types and strings.</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="ow">and</span> \
               <span class="ow">not</span> <span class="nb">str</span> <span class="ow">in</span> <span class="n">typeList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">typeList</span><span class="p">:</span>
                <span class="n">typeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="c1"># Prohibit sequence of strings or a mix of numbers and string.</span>
        <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="nb">str</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">typeList</span><span class="p">:</span>
            <span class="n">typeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">typeList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">break</span>
    <span class="k">if</span> <span class="nb">str</span> <span class="ow">in</span> <span class="n">typeList</span><span class="p">:</span>
        <span class="n">xtype</span> <span class="o">=</span> <span class="n">SDC</span><span class="o">.</span><span class="n">CHAR8</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># double is &quot;stronger&quot; than int</span>
    <span class="k">elif</span> <span class="nb">float</span> <span class="ow">in</span> <span class="n">typeList</span><span class="p">:</span>
        <span class="n">xtype</span> <span class="o">=</span> <span class="n">SDC</span><span class="o">.</span><span class="n">FLOAT64</span>
    <span class="k">elif</span> <span class="nb">int</span> <span class="ow">in</span> <span class="n">typeList</span><span class="p">:</span>
        <span class="n">xtype</span> <span class="o">=</span> <span class="n">SDC</span><span class="o">.</span><span class="n">INT32</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;Illegal attribute value&quot;</span><span class="p">)</span>

    <span class="c1"># Assign value</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">SDAttr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xtype</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">HDF4Error</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">HDF4Error</span><span class="p">(</span><span class="s2">&quot;cannot set attribute: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">msg</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_array_to_ret</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">nValues</span><span class="p">):</span>

    <span class="c1"># Convert array &#39;buf&#39; to a scalar or a list.</span>

    <span class="k">if</span> <span class="n">nValues</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nValues</span><span class="p">):</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">ret</span>

<span class="k">def</span> <span class="nf">_array_to_str</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">nValues</span><span class="p">):</span>

    <span class="c1"># Convert array of bytes &#39;buf&#39; to a string.</span>

    <span class="c1"># Return empty string if there is no value.</span>
    <span class="k">if</span> <span class="n">nValues</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span>
    <span class="c1"># When there is just one value, _array_to_ret returns a scalar</span>
    <span class="c1"># over which we cannot iterate.</span>
    <span class="k">if</span> <span class="n">nValues</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">chrs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">chrs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">_array_to_ret</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">nValues</span><span class="p">)]</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chrs</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pyhdf 0.10.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, pyhdf authors.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>